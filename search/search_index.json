{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Hyperion Task Processor The powerful and free task processing tool Main goals For the main goals and the current progress please have a look at current milestone. You can see there which issues are closed and which ones are in the queue. The list of open issues is not necessarily complete, it means there might be further features added to that milestone. Status I'm constantly developing on it in my free time. The current issue(s) I'm working on are pinned and can be seen at the top of the issue list. Issues If you are using the tool and find things please report an issue but please check before that the issue isn't already there. The issue tracker is here . Please do not assign tags (please leave that to me). Thank you. Please also provide concrete examples that I'm able to reproduce the problem. Discussions Please feel to start/contribute in discussions here . Documentation The current documentation will be here . Have a look at the top menu under menu entry Index . As mentioned the tool is not yet production ready - so please be patient - there will be detailed documentation and examples. The name \" In Greek mythology, Hyperion was one of the twelve Titan children of Gaia (Earth) \" (see https://en.wikipedia.org/wiki/Hyperion_(Titan )). A nice name and I like mythology - just a little bit; that's all.","title":"Home"},{"location":"#welcome-to-the-hyperion-task-processor","text":"The powerful and free task processing tool","title":"Welcome to the Hyperion Task Processor"},{"location":"#main-goals","text":"For the main goals and the current progress please have a look at current milestone. You can see there which issues are closed and which ones are in the queue. The list of open issues is not necessarily complete, it means there might be further features added to that milestone.","title":"Main goals"},{"location":"#status","text":"I'm constantly developing on it in my free time. The current issue(s) I'm working on are pinned and can be seen at the top of the issue list.","title":"Status"},{"location":"#issues","text":"If you are using the tool and find things please report an issue but please check before that the issue isn't already there. The issue tracker is here . Please do not assign tags (please leave that to me). Thank you. Please also provide concrete examples that I'm able to reproduce the problem.","title":"Issues"},{"location":"#discussions","text":"Please feel to start/contribute in discussions here .","title":"Discussions"},{"location":"#documentation","text":"The current documentation will be here . Have a look at the top menu under menu entry Index . As mentioned the tool is not yet production ready - so please be patient - there will be detailed documentation and examples.","title":"Documentation"},{"location":"#the-name","text":"\" In Greek mythology, Hyperion was one of the twelve Titan children of Gaia (Earth) \" (see https://en.wikipedia.org/wiki/Hyperion_(Titan )). A nice name and I like mythology - just a little bit; that's all.","title":"The name"},{"location":"basic-coded-task-features/","text":"Basic code tasks Coded task are those where you can put code on a task. Currently supported are: Grooovy Powershell Windows Batch Unix Docker image Docker container All Hyperion tasks have basic task features . Following attributes are additional available for coded tasks: code - the code depends on implementation (see list above). Optional the code also might be a valid path and filename. The code also allows templating . You can write multiline code by using a pipe symbol in the first line: - type: groovy code: | println 'hello world 1' println 'hello world 2' println 'hello world 3'","title":"Basic code tasks"},{"location":"basic-coded-task-features/#basic-code-tasks","text":"Coded task are those where you can put code on a task. Currently supported are: Grooovy Powershell Windows Batch Unix Docker image Docker container All Hyperion tasks have basic task features . Following attributes are additional available for coded tasks: code - the code depends on implementation (see list above). Optional the code also might be a valid path and filename. The code also allows templating . You can write multiline code by using a pipe symbol in the first line: - type: groovy code: | println 'hello world 1' println 'hello world 2' println 'hello world 3'","title":"Basic code tasks"},{"location":"basic-task-features/","text":"Basic tasks features Following attributes are commonly available: title - the title is optional and is used for logging to show which task is running. For the title templating is supported. tags - an optional list with texts that can be used to filter tasks. See hyperion for the command line options on how to use tags. variable - an optional variable definition. If not provided the default name of the variable is \" default \" and the whole stdout of the task (process) is captured. with - an optional list with values. For each entry the task will be executed. Through templating th current value of the entry and the zero based index of the entry will be available in the code ( {{ with.index }} and {{ with.value }} ). Finally the use of it does not differ from writing as many tasks as you have \"with\" entries one after the other; it's a short way to write it using the attribute. In a task group where parallel is set to false the tasks are running in the order they appear otherwise they run in parallel (including the \"with\" tasks). The value of the \"with\" list is not checked to be equal in its structure; the user has to care for it when this is the case. On each with value (structure) templating is supported. Variable A variable has following attributes: name optional name of the variable. The default name is \" default \". regex optional Java regex. The default is to capture the whole stdout of the task (process). group optional regex group. The default regex group is 0. linebyline optional boolean to apply regex per line instead on whole captured stdout. The default is false. Using the \"with\" attribute The following example demonstrates one way to handle the situation that two entries are different in its structure. The used Template Engine (see build ) allows to use an if/else . This example is also used in the Unittests. - type: groovy title: a simple example code: | {% if with.index == 0 %} println '{{ with.value }}' {% else %} println '{{ with.value.attributes.test3.attributes.test4.value }}' {% endif %} with: - hello world 1! - test1: - hello world 2! test2: hello world 3! test3: test4: hello world 4!","title":"Basic tasks features"},{"location":"basic-task-features/#basic-tasks-features","text":"Following attributes are commonly available: title - the title is optional and is used for logging to show which task is running. For the title templating is supported. tags - an optional list with texts that can be used to filter tasks. See hyperion for the command line options on how to use tags. variable - an optional variable definition. If not provided the default name of the variable is \" default \" and the whole stdout of the task (process) is captured. with - an optional list with values. For each entry the task will be executed. Through templating th current value of the entry and the zero based index of the entry will be available in the code ( {{ with.index }} and {{ with.value }} ). Finally the use of it does not differ from writing as many tasks as you have \"with\" entries one after the other; it's a short way to write it using the attribute. In a task group where parallel is set to false the tasks are running in the order they appear otherwise they run in parallel (including the \"with\" tasks). The value of the \"with\" list is not checked to be equal in its structure; the user has to care for it when this is the case. On each with value (structure) templating is supported.","title":"Basic tasks features"},{"location":"basic-task-features/#variable","text":"A variable has following attributes: name optional name of the variable. The default name is \" default \". regex optional Java regex. The default is to capture the whole stdout of the task (process). group optional regex group. The default regex group is 0. linebyline optional boolean to apply regex per line instead on whole captured stdout. The default is false.","title":"Variable"},{"location":"basic-task-features/#using-the-with-attribute","text":"The following example demonstrates one way to handle the situation that two entries are different in its structure. The used Template Engine (see build ) allows to use an if/else . This example is also used in the Unittests. - type: groovy title: a simple example code: | {% if with.index == 0 %} println '{{ with.value }}' {% else %} println '{{ with.value.attributes.test3.attributes.test4.value }}' {% endif %} with: - hello world 1! - test1: - hello world 2! test2: hello world 3! test3: test4: hello world 4!","title":"Using the \"with\" attribute"},{"location":"copy-file/","text":"File copy task In addition to the basic task features the file copy task has following attributes: source - required attribute with the path and filename that must exist. The attribute does allow templating . destination - required attribute with the path of filename or directory. The attribute does allow templating . The meaning of the value will be specified with the boolean attribute \"destination-is-directory\"; when it is set to true the filename of the source is appended to the path otherwise it is assumed that you have specified a path and filename. overwrite - optional boolean attribute. When set to true (default is false) the copy operation will overwrite the destination otherwise the task might fail when the destination already exists. ensure-path - optional boolean attribute. When set to true (default is false) the path of the filename or directory will be created when missing otherwise the task might fail when the path does not exist. destination-is-directory optional boolean attribute. When set to true (default is true) then the path defined in \"destination\" will be interpreted as directory. Minimal examples The following example does a copy and rename of a file at same path; when the destination file exists the task operation does fail. --- taskgroups: - title: test tasks: - type: copy-file source: c:\\temp\\test1.txt destination: c:\\temp\\test2.txt The following example copies a file (name remains) to a destination path; when the destination path doesn't exist it will be created. The expected result is here: c:\\temp\\test\\test1.txt. The attribute destination-is-directory is required here otherwise the task doesn't know that the defined destination is a path. When the destination file exists the task operation does fail. --- taskgroups: - title: test tasks: - type: copy-file source: c:\\temp\\test1.txt destination: c:\\temp\\test destination-is-directory: true ensure-path: true The following example does a copy and rename of a file to a different path; when the destination path doesn't exist it will be created. The expected result is here: c:\\temp\\test\\test2.txt. When the destination file exists the task operation does fail. --- taskgroups: - title: test tasks: - type: copy-file source: c:\\temp\\test1.txt destination: c:\\temp\\test\\test2.txt ensure-path: true That's the same example as the first one with the additional attribute overwrite set to true; when the destination exists it will be overwritten. --- taskgroups: - title: test tasks: - type: copy-file source: c:\\temp\\test1.txt destination: c:\\temp\\test2.txt overwrite: true Variable Usually a variable is used to capture the stdout; the default is then to capture all. In this case there is no stdout output. For this task the variable will contain the final path and filename when the copy operation has been successful. All variable options as explained in basic task features are still valid.","title":"File copy task"},{"location":"copy-file/#file-copy-task","text":"In addition to the basic task features the file copy task has following attributes: source - required attribute with the path and filename that must exist. The attribute does allow templating . destination - required attribute with the path of filename or directory. The attribute does allow templating . The meaning of the value will be specified with the boolean attribute \"destination-is-directory\"; when it is set to true the filename of the source is appended to the path otherwise it is assumed that you have specified a path and filename. overwrite - optional boolean attribute. When set to true (default is false) the copy operation will overwrite the destination otherwise the task might fail when the destination already exists. ensure-path - optional boolean attribute. When set to true (default is false) the path of the filename or directory will be created when missing otherwise the task might fail when the path does not exist. destination-is-directory optional boolean attribute. When set to true (default is true) then the path defined in \"destination\" will be interpreted as directory.","title":"File copy task"},{"location":"copy-file/#minimal-examples","text":"The following example does a copy and rename of a file at same path; when the destination file exists the task operation does fail. --- taskgroups: - title: test tasks: - type: copy-file source: c:\\temp\\test1.txt destination: c:\\temp\\test2.txt The following example copies a file (name remains) to a destination path; when the destination path doesn't exist it will be created. The expected result is here: c:\\temp\\test\\test1.txt. The attribute destination-is-directory is required here otherwise the task doesn't know that the defined destination is a path. When the destination file exists the task operation does fail. --- taskgroups: - title: test tasks: - type: copy-file source: c:\\temp\\test1.txt destination: c:\\temp\\test destination-is-directory: true ensure-path: true The following example does a copy and rename of a file to a different path; when the destination path doesn't exist it will be created. The expected result is here: c:\\temp\\test\\test2.txt. When the destination file exists the task operation does fail. --- taskgroups: - title: test tasks: - type: copy-file source: c:\\temp\\test1.txt destination: c:\\temp\\test\\test2.txt ensure-path: true That's the same example as the first one with the additional attribute overwrite set to true; when the destination exists it will be overwritten. --- taskgroups: - title: test tasks: - type: copy-file source: c:\\temp\\test1.txt destination: c:\\temp\\test2.txt overwrite: true","title":"Minimal examples"},{"location":"copy-file/#variable","text":"Usually a variable is used to capture the stdout; the default is then to capture all. In this case there is no stdout output. For this task the variable will contain the final path and filename when the copy operation has been successful. All variable options as explained in basic task features are still valid.","title":"Variable"},{"location":"docker-container/","text":"Docker container task This doesn't intend to explain Docker. Please refer to official Docker documentation for details on it. It's about the Docker container task. The docker container does offer basic coded task features . In addition following attributes are available: image-name - the mandatory attribute specifies the name of the docker image to use image-version - the optional string attribute specifies the version of the docker image to use. If not specified the default is latest . detached - the optional boolean attribute specified whether to run the docker container in detached (background) mode. If not specified the default is false . platform - the optional parameter for what kind of Docker container to run. If not specified the Default is unix (read a bit later about platform). It does have the effect that the generated temporary script - that will be executed by the Docker container - is either passed to cmd /c or sh -c . A few things to mention here about Docker: Docker is an external tool that must exist otherwise you cannot use the task; even more the Hyperion tool will throw an error when the Docker tool has not been found. The default is to run Docker container with Unix images. On Windows you are able to switch to Windows container so you could run Windows batch code inside the Docker container. Usually you can switch to either use the one platform or the other platform but not both at same time. From documentation, it seems an experimental feature that can be turned on allowing you to specify the parameter --platform with the values windows or unix so you could use both at same time. Since it is experimental and I cannot rely on yet that this is turned on by default I don't generate that parameter; means you cannot use both at same time for now. Also on Windows you have to be aware that sharing a drive is to be adjusted in the settings of Docker. Be aware that right now Hyperion differs two mounts which are currently done automatically: the mount of the current working directory (as /work) the mount of the path usually used for generating temporary files and folders by the standard Java API. At least it means you might have to allow more than one Windows drive to be shared with the Docker container . Since you probably want to run Hyperion processing automatically it is advisable to adjust this in advance otherwise the Docker process is trying to ask you via Dialog. The minimal example It's really easy and doesn't differ much from other task. Following details: --- taskgroups: - title: test tasks: - type: docker-container code: echo \"hello world!\" image-name: debian Running detached It's nothing you would do in a real environment but that simple example demonstrates how it does work: After running you can do a \"docker ps -a\" and you will see the container running. After 30 seconds the container will automatically go away since --rm is also used. You can use this for running a Database or an application server in it. The variable (also not specified here) will contain the id of the container that can be used to work on the container (example: using the id to stop the container). --- taskgroups: - title: test tasks: - type: docker-container code: sleep 30 image-name: debian detached: true Minimal example with tags The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: docker-container code: echo \"hello world!\" image-name: debian tags: - simple - example Example with variable The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: docker-container title: a simple example code: echo \"---> this is a demo <---\" image-name: debian variable: name: test2 regex: \">(.*)<\" group: 1 Example with templating The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: docker-container title: a simple example 1 code: echo \"hello world!\" docker-image: debian - type: dockier-container title: a simple example 2 code: echo \"{{ variables.default.value }}\" docker-image: debian In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: docker-container title: a simple example 1 code: echo \"{{ model.attributest.description }}\" docker-image: debian The rules on how to access the individual elements of a model are explained here .","title":"Docker container task"},{"location":"docker-container/#docker-container-task","text":"This doesn't intend to explain Docker. Please refer to official Docker documentation for details on it. It's about the Docker container task. The docker container does offer basic coded task features . In addition following attributes are available: image-name - the mandatory attribute specifies the name of the docker image to use image-version - the optional string attribute specifies the version of the docker image to use. If not specified the default is latest . detached - the optional boolean attribute specified whether to run the docker container in detached (background) mode. If not specified the default is false . platform - the optional parameter for what kind of Docker container to run. If not specified the Default is unix (read a bit later about platform). It does have the effect that the generated temporary script - that will be executed by the Docker container - is either passed to cmd /c or sh -c . A few things to mention here about Docker: Docker is an external tool that must exist otherwise you cannot use the task; even more the Hyperion tool will throw an error when the Docker tool has not been found. The default is to run Docker container with Unix images. On Windows you are able to switch to Windows container so you could run Windows batch code inside the Docker container. Usually you can switch to either use the one platform or the other platform but not both at same time. From documentation, it seems an experimental feature that can be turned on allowing you to specify the parameter --platform with the values windows or unix so you could use both at same time. Since it is experimental and I cannot rely on yet that this is turned on by default I don't generate that parameter; means you cannot use both at same time for now. Also on Windows you have to be aware that sharing a drive is to be adjusted in the settings of Docker. Be aware that right now Hyperion differs two mounts which are currently done automatically: the mount of the current working directory (as /work) the mount of the path usually used for generating temporary files and folders by the standard Java API. At least it means you might have to allow more than one Windows drive to be shared with the Docker container . Since you probably want to run Hyperion processing automatically it is advisable to adjust this in advance otherwise the Docker process is trying to ask you via Dialog.","title":"Docker container task"},{"location":"docker-container/#the-minimal-example","text":"It's really easy and doesn't differ much from other task. Following details: --- taskgroups: - title: test tasks: - type: docker-container code: echo \"hello world!\" image-name: debian","title":"The minimal example"},{"location":"docker-container/#running-detached","text":"It's nothing you would do in a real environment but that simple example demonstrates how it does work: After running you can do a \"docker ps -a\" and you will see the container running. After 30 seconds the container will automatically go away since --rm is also used. You can use this for running a Database or an application server in it. The variable (also not specified here) will contain the id of the container that can be used to work on the container (example: using the id to stop the container). --- taskgroups: - title: test tasks: - type: docker-container code: sleep 30 image-name: debian detached: true","title":"Running detached"},{"location":"docker-container/#minimal-example-with-tags","text":"The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: docker-container code: echo \"hello world!\" image-name: debian tags: - simple - example","title":"Minimal example with tags"},{"location":"docker-container/#example-with-variable","text":"The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: docker-container title: a simple example code: echo \"---> this is a demo <---\" image-name: debian variable: name: test2 regex: \">(.*)<\" group: 1","title":"Example with variable"},{"location":"docker-container/#example-with-templating","text":"The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: docker-container title: a simple example 1 code: echo \"hello world!\" docker-image: debian - type: dockier-container title: a simple example 2 code: echo \"{{ variables.default.value }}\" docker-image: debian In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: docker-container title: a simple example 1 code: echo \"{{ model.attributest.description }}\" docker-image: debian The rules on how to access the individual elements of a model are explained here .","title":"Example with templating"},{"location":"docker-image/","text":"Docker image task This doesn't intend to explain Docker. Please refer to official Docker documentation for details on it. It's about the Docker container task. The basic coded task features are language independent and explained in the link including: Having an optional title attribute Using the code in attribute with same name Having an optional tag attribute Having an optional variable attribute Having an optional with attribute A few things to mention here about Docker: Docker is an external tool that must exist otherwise you cannot use the task; even more the Hyperion tool will throw an error when the Docker tool has not been found. The default is to run create Unix images. On Windows you are able to switch to Windows platform so you could run Windows batch code inside the Docker container that does prepare the image. Usually you can switch to either use the one platform or the other platform but not both at same time. From documentation, it seems an experimental feature that can be turned on allowing you to specify the parameter --platform with the values windows or unix so you could use both at same time. Since it is experimental and I cannot rely on yet that this is turned on by default I don't generate that parameter; means you cannot use both at same time for now. The basic coded task features Following features are basic task features: variable templating (model, matrix variables, task group variables) tagging Those features are documented in basic coded task features , The minimal example It doesn't differ much from other task. Following details: The attribute repository-tag defines the repository and tag of the image when the build of the image has been successful. The following code also can be found in the example folder. The batch hello-world-docker-image-for-unix.cmd demonstrates what the Hyperion tool is basically doing. The code also can reference a path and filename of an existing Dockerfile. --- taskgroups: - title: test parallel: false tasks: - type: docker-image repository-tag: hello-world:latest code: | FROM centos:latest COPY hello-world.sh . - type: docker-container title: a simple example code: /hello-world.sh image-name: hello-world External Documentation https://docs.docker.com/engine/reference/builder/ https://docs.docker.com/engine/reference/commandline/tag/","title":"Docker image task"},{"location":"docker-image/#docker-image-task","text":"This doesn't intend to explain Docker. Please refer to official Docker documentation for details on it. It's about the Docker container task. The basic coded task features are language independent and explained in the link including: Having an optional title attribute Using the code in attribute with same name Having an optional tag attribute Having an optional variable attribute Having an optional with attribute A few things to mention here about Docker: Docker is an external tool that must exist otherwise you cannot use the task; even more the Hyperion tool will throw an error when the Docker tool has not been found. The default is to run create Unix images. On Windows you are able to switch to Windows platform so you could run Windows batch code inside the Docker container that does prepare the image. Usually you can switch to either use the one platform or the other platform but not both at same time. From documentation, it seems an experimental feature that can be turned on allowing you to specify the parameter --platform with the values windows or unix so you could use both at same time. Since it is experimental and I cannot rely on yet that this is turned on by default I don't generate that parameter; means you cannot use both at same time for now.","title":"Docker image task"},{"location":"docker-image/#the-basic-coded-task-features","text":"Following features are basic task features: variable templating (model, matrix variables, task group variables) tagging Those features are documented in basic coded task features ,","title":"The basic coded task features"},{"location":"docker-image/#the-minimal-example","text":"It doesn't differ much from other task. Following details: The attribute repository-tag defines the repository and tag of the image when the build of the image has been successful. The following code also can be found in the example folder. The batch hello-world-docker-image-for-unix.cmd demonstrates what the Hyperion tool is basically doing. The code also can reference a path and filename of an existing Dockerfile. --- taskgroups: - title: test parallel: false tasks: - type: docker-image repository-tag: hello-world:latest code: | FROM centos:latest COPY hello-world.sh . - type: docker-container title: a simple example code: /hello-world.sh image-name: hello-world","title":"The minimal example"},{"location":"docker-image/#external-documentation","text":"https://docs.docker.com/engine/reference/builder/ https://docs.docker.com/engine/reference/commandline/tag/","title":"External Documentation"},{"location":"download-task/","text":"Download Task In addition to the basic task features the file copy task has following attributes: url - required attribute with url where to download the file from. destination - required attribute with the path of filename or directory. The attribute does allow templating . The meaning of the value will be specified with the boolean attribute \"destination-is-directory\"; when it is set to true the filename of the source is appended to the path otherwise it is assumed that you have specified a path and filename. overwrite - optional boolean attribute. When set to true (default is false) the copy operation will overwrite the destination otherwise the task might fail when the destination already exists. ensure-path - optional boolean attribute. When set to true (default is false) the path of the filename or directory will be created when missing otherwise the task might fail when the path does not exist. Minimal examples The following example does write some text to a file; when the destination file exists the task operation does fail. --- taskgroups: - title: test tasks: - type: download content: https://raw.githubusercontent.com/thomas-lehmann-private/hyperion-task-processor/main/README.md destination: c:\\temp\\test.txt The following example allows overwriting an existing file and and missing folders will be automatically created. --- taskgroups: - title: test tasks: - type: download content: https://raw.githubusercontent.com/thomas-lehmann-private/hyperion-task-processor/main/README.md destination: c:\\temp\\temp\\temp\\test.txt overwrite: true ensure-path: true Variable Usually a variable is used to capture the stdout; the default is then to capture all. In this case there is no stdout output. For this task the variable will contain the final path and filename when the copy operation has been successful. All variable options as explained in basic task features are still valid.","title":"Download Task"},{"location":"download-task/#download-task","text":"In addition to the basic task features the file copy task has following attributes: url - required attribute with url where to download the file from. destination - required attribute with the path of filename or directory. The attribute does allow templating . The meaning of the value will be specified with the boolean attribute \"destination-is-directory\"; when it is set to true the filename of the source is appended to the path otherwise it is assumed that you have specified a path and filename. overwrite - optional boolean attribute. When set to true (default is false) the copy operation will overwrite the destination otherwise the task might fail when the destination already exists. ensure-path - optional boolean attribute. When set to true (default is false) the path of the filename or directory will be created when missing otherwise the task might fail when the path does not exist.","title":"Download Task"},{"location":"download-task/#minimal-examples","text":"The following example does write some text to a file; when the destination file exists the task operation does fail. --- taskgroups: - title: test tasks: - type: download content: https://raw.githubusercontent.com/thomas-lehmann-private/hyperion-task-processor/main/README.md destination: c:\\temp\\test.txt The following example allows overwriting an existing file and and missing folders will be automatically created. --- taskgroups: - title: test tasks: - type: download content: https://raw.githubusercontent.com/thomas-lehmann-private/hyperion-task-processor/main/README.md destination: c:\\temp\\temp\\temp\\test.txt overwrite: true ensure-path: true","title":"Minimal examples"},{"location":"download-task/#variable","text":"Usually a variable is used to capture the stdout; the default is then to capture all. In this case there is no stdout output. For this task the variable will contain the final path and filename when the copy operation has been successful. All variable options as explained in basic task features are still valid.","title":"Variable"},{"location":"groovy/","text":"Groovy task This page doesn't intend to explain Groovy. So please refer to official Groovy documentation for details on it. It's about the Groovy task. The basic coded task features are language independent and explained in the link including: Having an optional title attribute Using the code in attribute with same name Having an optional tag attribute Having an optional variable attribute Having an optional with attribute Minimal example The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: groovy code: println 'hello world!' Minimal example with tags The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: groovy code: println 'hello world!' tags: - simple - example Example with variable The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: groovy title: a simple example code: println '---> this is a demo <---' variable: name: test2 regex: \">(.*)<\" group: 1 Example with templating The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: groovy title: a simple example 1 code: println 'hello world!' - type: groovy title: a simple example 2 code: println '{{ variables.default.value }}' In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: groovy title: a simple example 1 code: println '{{ model.attributest.description }}' The rules on how to access the individual elements of a model are explained here .","title":"Groovy task"},{"location":"groovy/#groovy-task","text":"This page doesn't intend to explain Groovy. So please refer to official Groovy documentation for details on it. It's about the Groovy task. The basic coded task features are language independent and explained in the link including: Having an optional title attribute Using the code in attribute with same name Having an optional tag attribute Having an optional variable attribute Having an optional with attribute","title":"Groovy task"},{"location":"groovy/#minimal-example","text":"The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: groovy code: println 'hello world!'","title":"Minimal example"},{"location":"groovy/#minimal-example-with-tags","text":"The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: groovy code: println 'hello world!' tags: - simple - example","title":"Minimal example with tags"},{"location":"groovy/#example-with-variable","text":"The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: groovy title: a simple example code: println '---> this is a demo <---' variable: name: test2 regex: \">(.*)<\" group: 1","title":"Example with variable"},{"location":"groovy/#example-with-templating","text":"The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: groovy title: a simple example 1 code: println 'hello world!' - type: groovy title: a simple example 2 code: println '{{ variables.default.value }}' In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: groovy title: a simple example 1 code: println '{{ model.attributest.description }}' The rules on how to access the individual elements of a model are explained here .","title":"Example with templating"},{"location":"hyperion-task-processor/","text":"Application Introduction The hyperion task processor tool allows processing a YAML document with tasks. There can be many tasks like: Powershell (functional on Windows only, for the moment) Batch (functional on Windows only) Shell (functional on Unix only) Groovy (all platforms because: embedded) JShell (all platforms because: embedded) That's the current list and will be updated when new tasks will be added. Command line interface The current command line options look like following: java -jar hyperion-task-processor-1.0.0-SNAPSHOT.jar [global options] [command [command options]] version: 1.0.0-SNAPSHOT, build timestamp: 2021-06-26 14:55 author: Thomas Lehmann <thomas.lehmann.private@gmail.com> Global options: -h, --help - displaying this help --timeout-taskgroup=<int> - timeout for each taskgroup (minutes) -t<str>, --tag=<str> - provide tag to filter tasks [repeatable] List of available commands: run - Running one document with tasks to be processed thirdparty - Reporting the used third-party libraries capabilities - Reporting capabilities of system where Hyperion should run Options for command 'run': -f<path>, --file=<path> - Document with tasks to be processed [required] --temporary-path=<path> - Defining temporary path Also those help should be good enough to help on usage here a few notes: if you use --help you get the help. However, if you would also specify the command \"run\" you are forced to specify the path of the document too. Global options have to be specified before a command otherwise options would be interpreted as option related to a command and --help would be unknown then. You can specify one command only. Specifying a tag all tasks will run that have that tag only. Tasks with other tags or even without tags will be ignored. Run command The run command allows to run one document with tasks. the required --file option is the path and filename of the YAML document containing the tasks. the optional --temporary-path option allows you to specify a different path for temporary files than specified by the system. The path must exist and is required to be a directory. You have to ensure that all necessary permissions are given (as they are usually given for the default temporary path). Thirdparty command The thirdparty command prints all used third party components. Please also have a look at build ; dependencies are listed there too additionally with url and license. Capabilities command The capabilities command prints all system capabilities relevant for the Hyperion tool. An example output might look like following: > java -jar hyperion-task-processor-1.0.0-SNAPSHOT-shaded.jar capabilities Java: AdoptOpenJDK-11.0.11+9 (class version=55.0) Operating System: Windows 10 (arch=amd64) Groovy (embedded): 3.0.7 Docker: 19.03.8, build afacb8b Powershell: 5.1.19041.1023","title":"Application"},{"location":"hyperion-task-processor/#application","text":"","title":"Application"},{"location":"hyperion-task-processor/#introduction","text":"The hyperion task processor tool allows processing a YAML document with tasks. There can be many tasks like: Powershell (functional on Windows only, for the moment) Batch (functional on Windows only) Shell (functional on Unix only) Groovy (all platforms because: embedded) JShell (all platforms because: embedded) That's the current list and will be updated when new tasks will be added.","title":"Introduction"},{"location":"hyperion-task-processor/#command-line-interface","text":"The current command line options look like following: java -jar hyperion-task-processor-1.0.0-SNAPSHOT.jar [global options] [command [command options]] version: 1.0.0-SNAPSHOT, build timestamp: 2021-06-26 14:55 author: Thomas Lehmann <thomas.lehmann.private@gmail.com> Global options: -h, --help - displaying this help --timeout-taskgroup=<int> - timeout for each taskgroup (minutes) -t<str>, --tag=<str> - provide tag to filter tasks [repeatable] List of available commands: run - Running one document with tasks to be processed thirdparty - Reporting the used third-party libraries capabilities - Reporting capabilities of system where Hyperion should run Options for command 'run': -f<path>, --file=<path> - Document with tasks to be processed [required] --temporary-path=<path> - Defining temporary path Also those help should be good enough to help on usage here a few notes: if you use --help you get the help. However, if you would also specify the command \"run\" you are forced to specify the path of the document too. Global options have to be specified before a command otherwise options would be interpreted as option related to a command and --help would be unknown then. You can specify one command only. Specifying a tag all tasks will run that have that tag only. Tasks with other tags or even without tags will be ignored.","title":"Command line interface"},{"location":"hyperion-task-processor/#run-command","text":"The run command allows to run one document with tasks. the required --file option is the path and filename of the YAML document containing the tasks. the optional --temporary-path option allows you to specify a different path for temporary files than specified by the system. The path must exist and is required to be a directory. You have to ensure that all necessary permissions are given (as they are usually given for the default temporary path).","title":"Run command"},{"location":"hyperion-task-processor/#thirdparty-command","text":"The thirdparty command prints all used third party components. Please also have a look at build ; dependencies are listed there too additionally with url and license.","title":"Thirdparty command"},{"location":"hyperion-task-processor/#capabilities-command","text":"The capabilities command prints all system capabilities relevant for the Hyperion tool. An example output might look like following: > java -jar hyperion-task-processor-1.0.0-SNAPSHOT-shaded.jar capabilities Java: AdoptOpenJDK-11.0.11+9 (class version=55.0) Operating System: Windows 10 (arch=amd64) Groovy (embedded): 3.0.7 Docker: 19.03.8, build afacb8b Powershell: 5.1.19041.1023","title":"Capabilities command"},{"location":"matrix/","text":"Matrix Example --- matrix: - title: first run parameters: description: the first run sayHelloWorldCount: 3 - title: second run parameters: description: the second run sayHelloWorldCount: 2 taskgroups: - title: test group one tasks: - type: groovy title: running a Groovy task code: | println 'Groovy:{{ matrix.description }}' for (int ix = 1; ix <= {{ matrix.sayHelloWorldCount }}; ++ix) { println 'hello world ' + ix + '!' } Setup A matrix starts with the element matrix placed on same level as taskgroups. A matrix is a list. Each matrix item has two fields: title and parameters . The value for parameters is a key/value map (keys and values are interpreted as strings). Behaviour For each matrix item all existing task groups are running again. All variables stored in a previous run (per task group) are dropped.","title":"Matrix"},{"location":"matrix/#matrix","text":"","title":"Matrix"},{"location":"matrix/#example","text":"--- matrix: - title: first run parameters: description: the first run sayHelloWorldCount: 3 - title: second run parameters: description: the second run sayHelloWorldCount: 2 taskgroups: - title: test group one tasks: - type: groovy title: running a Groovy task code: | println 'Groovy:{{ matrix.description }}' for (int ix = 1; ix <= {{ matrix.sayHelloWorldCount }}; ++ix) { println 'hello world ' + ix + '!' }","title":"Example"},{"location":"matrix/#setup","text":"A matrix starts with the element matrix placed on same level as taskgroups. A matrix is a list. Each matrix item has two fields: title and parameters . The value for parameters is a key/value map (keys and values are interpreted as strings).","title":"Setup"},{"location":"matrix/#behaviour","text":"For each matrix item all existing task groups are running again. All variables stored in a previous run (per task group) are dropped.","title":"Behaviour"},{"location":"powershell/","text":"Powershell task This page doesn't intend to explain Powershell. So please refer to official Powershell documentation for details on it. It's about the Powershell task. The basic coded task features are language independent and explained in the link including: Having an optional title attribute Using the code in attribute with same name Having an optional tag attribute Having an optional variable attribute Having an optional with attribute Minimal example The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: powershell code: Write-Host \"hello world!\" Minimal example with tags The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: powershell code: Write-Host \"hello world!\" tags: - simple - example Example with variable The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: powershell title: a simple example code: Write-Host \"---> this is a demo <---\" variable: name: test2 regex: \">(.*)<\" group: 1 Example with templating The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: powershell title: a simple example 1 code: Write-Host \"hello world!\" - type: powershell title: a simple example 2 code: Write-Host \"{{ variables.default.value }}\" In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: powershell title: a simple example 1 code: Write-Host \"{{ model.attributest.description }}\" The rules on how to access the individual elements of a model are explained here .","title":"Powershell task"},{"location":"powershell/#powershell-task","text":"This page doesn't intend to explain Powershell. So please refer to official Powershell documentation for details on it. It's about the Powershell task. The basic coded task features are language independent and explained in the link including: Having an optional title attribute Using the code in attribute with same name Having an optional tag attribute Having an optional variable attribute Having an optional with attribute","title":"Powershell task"},{"location":"powershell/#minimal-example","text":"The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: powershell code: Write-Host \"hello world!\"","title":"Minimal example"},{"location":"powershell/#minimal-example-with-tags","text":"The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: powershell code: Write-Host \"hello world!\" tags: - simple - example","title":"Minimal example with tags"},{"location":"powershell/#example-with-variable","text":"The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: powershell title: a simple example code: Write-Host \"---> this is a demo <---\" variable: name: test2 regex: \">(.*)<\" group: 1","title":"Example with variable"},{"location":"powershell/#example-with-templating","text":"The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: powershell title: a simple example 1 code: Write-Host \"hello world!\" - type: powershell title: a simple example 2 code: Write-Host \"{{ variables.default.value }}\" In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: powershell title: a simple example 1 code: Write-Host \"{{ model.attributest.description }}\" The rules on how to access the individual elements of a model are explained here .","title":"Example with templating"},{"location":"requirements/","text":"Requirements Id Title Context Details 1 Provide coded tasks task feature details 2 Provide Powershell task task feature details 3 Printing capabilities to console system information details 4 Providing a Docker image task task feature details 5 Provide 'with' attribute on tasks allowing to repeat same task for each entry in the list task feature details 6 providing a copy file task task feature details 7 Provide windows batch task task feature details 8 Provide unix shell task task feature details 9 Provide Groovy task task feature details 10 Provide JShell task task feature details 11 Provide a Docker container task task feature details 12 Provide xslt task task feature details 13 Provide write to file task task feature details 14 Provide a download task file task feature details 15 Run docker container in detached mode docker task feature details","title":"Requirements"},{"location":"requirements/#requirements","text":"Id Title Context Details 1 Provide coded tasks task feature details 2 Provide Powershell task task feature details 3 Printing capabilities to console system information details 4 Providing a Docker image task task feature details 5 Provide 'with' attribute on tasks allowing to repeat same task for each entry in the list task feature details 6 providing a copy file task task feature details 7 Provide windows batch task task feature details 8 Provide unix shell task task feature details 9 Provide Groovy task task feature details 10 Provide JShell task task feature details 11 Provide a Docker container task task feature details 12 Provide xslt task task feature details 13 Provide write to file task task feature details 14 Provide a download task file task feature details 15 Run docker container in detached mode docker task feature details","title":"Requirements"},{"location":"shell/","text":"Shell task This page doesn't intend to explain Unix shell. So please refer to official Unix shell documentation for details on it. It's about the Unix shell task. The basic coded task features are language independent and explained in the link including: Having an optional title attribute Using the code in attribute with same name Having an optional tag attribute Having an optional variable attribute Having an optional with attribute Minimal example The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: shell code: echo \"hello world!\" Minimal example with tags The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: shell code: echo \"hello world!\" tags: - simple - example Example with variable The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: shell title: a simple example code: echo \"---> this is a demo <---\" variable: name: test2 regex: \">(.*)<\" group: 1 Example with templating The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: shell title: a simple example 1 code: echo \"hello world!\" - type: shell title: a simple example 2 code: echo \"{{ variables.default.value }}\" In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: shell title: a simple example 1 code: echo \"{{ model.attributest.description }}\" The rules on how to access the individual elements of a model are explained here .","title":"Shell task"},{"location":"shell/#shell-task","text":"This page doesn't intend to explain Unix shell. So please refer to official Unix shell documentation for details on it. It's about the Unix shell task. The basic coded task features are language independent and explained in the link including: Having an optional title attribute Using the code in attribute with same name Having an optional tag attribute Having an optional variable attribute Having an optional with attribute","title":"Shell task"},{"location":"shell/#minimal-example","text":"The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: shell code: echo \"hello world!\"","title":"Minimal example"},{"location":"shell/#minimal-example-with-tags","text":"The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: shell code: echo \"hello world!\" tags: - simple - example","title":"Minimal example with tags"},{"location":"shell/#example-with-variable","text":"The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: shell title: a simple example code: echo \"---> this is a demo <---\" variable: name: test2 regex: \">(.*)<\" group: 1","title":"Example with variable"},{"location":"shell/#example-with-templating","text":"The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: shell title: a simple example 1 code: echo \"hello world!\" - type: shell title: a simple example 2 code: echo \"{{ variables.default.value }}\" In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: shell title: a simple example 1 code: echo \"{{ model.attributest.description }}\" The rules on how to access the individual elements of a model are explained here .","title":"Example with templating"},{"location":"taskgroup/","text":"Taskgroup A task group basically has three information: a required title an optional boolean flag indicating whether tasks should run in parallel or in order a required list of tasks Minimal example The three tasks in this example are running one after the other in the specified order . --- taskgroups: - title: test tasks: - type: groovy code: println 'hello world 1!' - type: groovy code: println 'hello world 2!' - type: groovy code: println 'hello world 3!' Note Also no variables have been specified the variables are there. The name of those variables is then \"default\". You are able to evaluate the value of a previously set variable with that name using templating with following expression: {{ variables.default.value }} . See also : Templating Running tasks in parallel The three tasks in this example are running in parallel. The output will be the inverse order of what has been specified because of the sleep statements. --- taskgroups: - title: test parallel: true tasks: - type: groovy code: | sleep(2000) println 'hello world 1!' - type: groovy code: | sleep(1000) println 'hello world 2!' - type: groovy code: | println 'hello world 3!' Warning Also the variables are not specified here they are given. It means that the stdout of the tasks is always stored. If you don't specify the variable yourself then name of the task variable is always \"default\". Running tasks in parallel the situation is unfavorable since you cannot always rely on which value will be written into the variable except you control the order of the execution like shown in the example. For that situation a warning is logged by the tool to inform you that you have duplicate variable names. Of course this also will happen if you specify the same name for variables yourself multiple times.","title":"Taskgroup"},{"location":"taskgroup/#taskgroup","text":"A task group basically has three information: a required title an optional boolean flag indicating whether tasks should run in parallel or in order a required list of tasks","title":"Taskgroup"},{"location":"taskgroup/#minimal-example","text":"The three tasks in this example are running one after the other in the specified order . --- taskgroups: - title: test tasks: - type: groovy code: println 'hello world 1!' - type: groovy code: println 'hello world 2!' - type: groovy code: println 'hello world 3!' Note Also no variables have been specified the variables are there. The name of those variables is then \"default\". You are able to evaluate the value of a previously set variable with that name using templating with following expression: {{ variables.default.value }} . See also : Templating","title":"Minimal example"},{"location":"taskgroup/#running-tasks-in-parallel","text":"The three tasks in this example are running in parallel. The output will be the inverse order of what has been specified because of the sleep statements. --- taskgroups: - title: test parallel: true tasks: - type: groovy code: | sleep(2000) println 'hello world 1!' - type: groovy code: | sleep(1000) println 'hello world 2!' - type: groovy code: | println 'hello world 3!' Warning Also the variables are not specified here they are given. It means that the stdout of the tasks is always stored. If you don't specify the variable yourself then name of the task variable is always \"default\". Running tasks in parallel the situation is unfavorable since you cannot always rely on which value will be written into the variable except you control the order of the execution like shown in the example. For that situation a warning is logged by the tool to inform you that you have duplicate variable names. Of course this also will happen if you specify the same name for variables yourself multiple times.","title":"Running tasks in parallel"},{"location":"templating/","text":"Templating Introduction One of the most powerful feature of the Hyperion tool is the templating that allows you to the dynamic replacement in the code of the part. Hyperion offers currently following data sources: the model the task group variables the matrix parameters (see matrix ) the with parameters The model is a kind of freestyle hierarchical structure you can define to model the required data when running your tasks. The task group variables are initially empty and filled whenever a task has finished successfully. The matrix variables is a map of key/value both of type string and the \"with\" parameters is a list of value where each value is as powerful as a model; one entry is provided with index and current value of the list. Rendering is applied on embedded code as well as on referenced files. Accessing the variables Assuming you missed defining a variable on a task the name of a variable is \"default\". You then can access the variable in your task code with {{ variables.default.value }} . Assuming you evaluate a special path in your task writing it to a named variable \"path\" the possible evaluation in the next task would be {{ variables.path.value }} . It depends on of course whether tasks are running ordered or in parallel whether one task can read a variable of a previous task. Even more it's unpredictable for parallel tasks with same names to know which value will be given when you access it. Accessing the model The model - once understood - is a great way to modularize your task code also allowing reuse. For the next examples a few explanations: attributes - the term means that the object behind stores for a key a value; of course the can be multiple keys. The value can be a string, a number, a boolean, a list or - again - a key/value object. values - the means a list. The value can be a string, a number, a boolean or a key/value object. --- model: description: this is a simple example Trying to access this description you have to write {{ model.attributes.description }} . --- model: subModel: description: this is a simple example Here the value you get with {{ model.attributes.subModel.attributes.description }} --- model: descriptions: - this is a simple example Here the value you get with {{ model.attributes.descriptions.values[0] }} . model: actions: - name: action A command: println 'hello world 1 !' Here the name and the command can be accessed this way: {{ model.attributes.actions.values[0].attributes.name }} {{ model.attributes.actions.values[0].attributes.command }} If you want to know more about how this works then please also read here: https://pebbletemplates.io/wiki/guide/basic-usage/ (it shows internal usage as well as what you can do with it) (Near) Future enhancements Defining task group variables in the document","title":"Templating"},{"location":"templating/#templating","text":"","title":"Templating"},{"location":"templating/#introduction","text":"One of the most powerful feature of the Hyperion tool is the templating that allows you to the dynamic replacement in the code of the part. Hyperion offers currently following data sources: the model the task group variables the matrix parameters (see matrix ) the with parameters The model is a kind of freestyle hierarchical structure you can define to model the required data when running your tasks. The task group variables are initially empty and filled whenever a task has finished successfully. The matrix variables is a map of key/value both of type string and the \"with\" parameters is a list of value where each value is as powerful as a model; one entry is provided with index and current value of the list. Rendering is applied on embedded code as well as on referenced files.","title":"Introduction"},{"location":"templating/#accessing-the-variables","text":"Assuming you missed defining a variable on a task the name of a variable is \"default\". You then can access the variable in your task code with {{ variables.default.value }} . Assuming you evaluate a special path in your task writing it to a named variable \"path\" the possible evaluation in the next task would be {{ variables.path.value }} . It depends on of course whether tasks are running ordered or in parallel whether one task can read a variable of a previous task. Even more it's unpredictable for parallel tasks with same names to know which value will be given when you access it.","title":"Accessing the variables"},{"location":"templating/#accessing-the-model","text":"The model - once understood - is a great way to modularize your task code also allowing reuse. For the next examples a few explanations: attributes - the term means that the object behind stores for a key a value; of course the can be multiple keys. The value can be a string, a number, a boolean, a list or - again - a key/value object. values - the means a list. The value can be a string, a number, a boolean or a key/value object. --- model: description: this is a simple example Trying to access this description you have to write {{ model.attributes.description }} . --- model: subModel: description: this is a simple example Here the value you get with {{ model.attributes.subModel.attributes.description }} --- model: descriptions: - this is a simple example Here the value you get with {{ model.attributes.descriptions.values[0] }} . model: actions: - name: action A command: println 'hello world 1 !' Here the name and the command can be accessed this way: {{ model.attributes.actions.values[0].attributes.name }} {{ model.attributes.actions.values[0].attributes.command }} If you want to know more about how this works then please also read here: https://pebbletemplates.io/wiki/guide/basic-usage/ (it shows internal usage as well as what you can do with it)","title":"Accessing the model"},{"location":"templating/#near-future-enhancements","text":"Defining task group variables in the document","title":"(Near) Future enhancements"},{"location":"windows-batch/","text":"Windows Batch task This page doesn't intend to explain Windows batch. So please refer to official Windows batch documentation for details on it. It's about the Windows batch task. The basic coded task features are language independent and explained in the link including: Having an optional title attribute Using the code in attribute with same name Having an optional tag attribute Having an optional variable attribute Having an optional with attribute Minimal example The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: batch code: echo \"hello world!\" Minimal example with tags The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: batch code: echo \"hello world!\" tags: - simple - example Example with variable The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: batch title: a simple example code: echo \"---> this is a demo <---\" variable: name: test2 regex: \">(.*)<\" group: 1 Example with templating The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: batch title: a simple example 1 code: echo \"hello world!\" - type: batch title: a simple example 2 code: echo \"{{ variables.default.value }}\" In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: batch title: a simple example 1 code: echo \"{{ model.attributest.description }}\" The rules on how to access the individual elements of a model are explained here .","title":"Windows Batch task"},{"location":"windows-batch/#windows-batch-task","text":"This page doesn't intend to explain Windows batch. So please refer to official Windows batch documentation for details on it. It's about the Windows batch task. The basic coded task features are language independent and explained in the link including: Having an optional title attribute Using the code in attribute with same name Having an optional tag attribute Having an optional variable attribute Having an optional with attribute","title":"Windows Batch task"},{"location":"windows-batch/#minimal-example","text":"The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: batch code: echo \"hello world!\"","title":"Minimal example"},{"location":"windows-batch/#minimal-example-with-tags","text":"The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: batch code: echo \"hello world!\" tags: - simple - example","title":"Minimal example with tags"},{"location":"windows-batch/#example-with-variable","text":"The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: batch title: a simple example code: echo \"---> this is a demo <---\" variable: name: test2 regex: \">(.*)<\" group: 1","title":"Example with variable"},{"location":"windows-batch/#example-with-templating","text":"The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: batch title: a simple example 1 code: echo \"hello world!\" - type: batch title: a simple example 2 code: echo \"{{ variables.default.value }}\" In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: batch title: a simple example 1 code: echo \"{{ model.attributest.description }}\" The rules on how to access the individual elements of a model are explained here .","title":"Example with templating"},{"location":"write-file/","text":"Write File Task In addition to the basic task features the file copy task has following attributes: content - required attribute with the content to write to file. The attribute does allow templating . destination - required attribute with the path of filename or directory. The attribute does allow templating . The meaning of the value will be specified with the boolean attribute \"destination-is-directory\"; when it is set to true the filename of the source is appended to the path otherwise it is assumed that you have specified a path and filename. overwrite - optional boolean attribute. When set to true (default is false) the copy operation will overwrite the destination otherwise the task might fail when the destination already exists. ensure-path - optional boolean attribute. When set to true (default is false) the path of the filename or directory will be created when missing otherwise the task might fail when the path does not exist. Minimal examples The following example does write some text to a file; when the destination file exists the task operation does fail. --- taskgroups: - title: test tasks: - type: write-file content: hello world 1! destination: c:\\temp\\test.txt The following example allows overwriting an existing file and and missing folders will be automatically created. --- taskgroups: - title: test tasks: - type: write-file content: hello world 1! destination: c:\\temp\\temp\\temp\\test.txt overwrite: true ensure-path: true Variable Usually a variable is used to capture the stdout; the default is then to capture all. In this case there is no stdout output. For this task the variable will contain the final path and filename when the copy operation has been successful. All variable options as explained in basic task features are still valid.","title":"Write File Task"},{"location":"write-file/#write-file-task","text":"In addition to the basic task features the file copy task has following attributes: content - required attribute with the content to write to file. The attribute does allow templating . destination - required attribute with the path of filename or directory. The attribute does allow templating . The meaning of the value will be specified with the boolean attribute \"destination-is-directory\"; when it is set to true the filename of the source is appended to the path otherwise it is assumed that you have specified a path and filename. overwrite - optional boolean attribute. When set to true (default is false) the copy operation will overwrite the destination otherwise the task might fail when the destination already exists. ensure-path - optional boolean attribute. When set to true (default is false) the path of the filename or directory will be created when missing otherwise the task might fail when the path does not exist.","title":"Write File Task"},{"location":"write-file/#minimal-examples","text":"The following example does write some text to a file; when the destination file exists the task operation does fail. --- taskgroups: - title: test tasks: - type: write-file content: hello world 1! destination: c:\\temp\\test.txt The following example allows overwriting an existing file and and missing folders will be automatically created. --- taskgroups: - title: test tasks: - type: write-file content: hello world 1! destination: c:\\temp\\temp\\temp\\test.txt overwrite: true ensure-path: true","title":"Minimal examples"},{"location":"write-file/#variable","text":"Usually a variable is used to capture the stdout; the default is then to capture all. In this case there is no stdout output. For this task the variable will contain the final path and filename when the copy operation has been successful. All variable options as explained in basic task features are still valid.","title":"Variable"},{"location":"xsl-transform/","text":"XSL Transform Task In addition to the basic task features the file copy task has following attributes: xsl - the required attribute represents an embedded XSL transformation document or a valid path and filename of such a document. The attribute does allow templating . xsl - the required attribute represents an embedded XML document or a valid path and filename of such a document. The attribute does allow templating . Minimal examples The following example does a transformation storing the result into the variable (here the variable name is 'default'). --- taskgroups: - title: test tasks: - type: xsl-transform xsl: c:\\temp\\test1.xsl xml: c:\\temp\\test2.xml The following with embedded: --- taskgroups: - title: test tasks: - type: xsl-transform xsl: | <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" version=\"3.0\"> <xsl:output method=\"html\" indent=\"yes\" /> <xsl:template match=\"/\"> <html> <body> <table> <tr> <th>title</th> <th>author</th> </tr> <xsl:apply-templates select=\".//book\"/> </table> </body> </html> </xsl:template> <xsl:template match=\"book\"> <tr> <td><xsl:value-of select=\"title\" /></td> <td><xsl:value-of select=\"author\" /></td> </tr> </xsl:template> </xsl:stylesheet> xml: | <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <books> <book> <title>Death on the Nile</title> <author>Agatha Christie</author> </book> <book> <title>Evil Under the Sun</title> <author>Agatha Christie</author> </book> <book> <title>Too Many Cooks</title> <author>Rex Stout</author> </book> <book> <title>The Big Sleep</title> <author>Raymond Chandler</author> </book> <book> <title>The Long Good-Bye</title> <author>Raymond Chandler</author> </book> </books>","title":"XSL Transform Task"},{"location":"xsl-transform/#xsl-transform-task","text":"In addition to the basic task features the file copy task has following attributes: xsl - the required attribute represents an embedded XSL transformation document or a valid path and filename of such a document. The attribute does allow templating . xsl - the required attribute represents an embedded XML document or a valid path and filename of such a document. The attribute does allow templating .","title":"XSL Transform Task"},{"location":"xsl-transform/#minimal-examples","text":"The following example does a transformation storing the result into the variable (here the variable name is 'default'). --- taskgroups: - title: test tasks: - type: xsl-transform xsl: c:\\temp\\test1.xsl xml: c:\\temp\\test2.xml The following with embedded: --- taskgroups: - title: test tasks: - type: xsl-transform xsl: | <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" version=\"3.0\"> <xsl:output method=\"html\" indent=\"yes\" /> <xsl:template match=\"/\"> <html> <body> <table> <tr> <th>title</th> <th>author</th> </tr> <xsl:apply-templates select=\".//book\"/> </table> </body> </html> </xsl:template> <xsl:template match=\"book\"> <tr> <td><xsl:value-of select=\"title\" /></td> <td><xsl:value-of select=\"author\" /></td> </tr> </xsl:template> </xsl:stylesheet> xml: | <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <books> <book> <title>Death on the Nile</title> <author>Agatha Christie</author> </book> <book> <title>Evil Under the Sun</title> <author>Agatha Christie</author> </book> <book> <title>Too Many Cooks</title> <author>Rex Stout</author> </book> <book> <title>The Big Sleep</title> <author>Raymond Chandler</author> </book> <book> <title>The Long Good-Bye</title> <author>Raymond Chandler</author> </book> </books>","title":"Minimal examples"},{"location":"internal/build/","text":"Build Quick and easy The build is organized with Maven. You don't have to install Maven because Maven Wrapper ( https://github.com/takari/maven-wrapper ) is used. On any system following command is sufficient as long as Java is given ( minimum Version : 11): ./mvnw On Unix based systems this is the exact filename of the script that is executed. On Windows it's the mvnw.cmd script (anyway you do not have to specify the extension that's why it looks and feel identical on all systems). Maven Profiles There are two profiles; one for Windows and one for Unix based systems. The main reason for two profiles is that the code coverage is different since not every test can be executed on every system (example: The UnixShellTaskTest can run on Unix based systems only). The reason to use a profile in general is to be able to define default goals, so you do not have to specify them on command line each time (convenience reason). Default goals The default goals are: clean package javadoc:jar verify clean - removes the target folder package - includes all previous goals like resource filtering, compiling and running tests. The package is combining the concrete jar with all dependencies into one jar that allows to use it standalone. javadoc:jar - generate the Javadoc HTML documentation and the javadoc jar. verify - is running all static code analysis (including the analysis of the code coverage). Maven Dependencies Test dependencies Those dependencies are available only while testing. Dependency Homepage License Usage org.junit.jupiter:junit-jupiter-api:5.5.2 https://junit.org/junit5/ Eclipse Public License - v 2.0 Unittests org.junit.jupiter:junit-jupiter-engine:5.5.2 https://junit.org/junit5/ Eclipse Public License - v 2.0 Unittests org.junit.jupiter:junit-jupiter-params:5.5.2 https://junit.org/junit5/ Eclipse Public License - v 2.0 Unittests Runtime dependencies Those dependencies are required at runtime and taken by the Maven shade plugin when packaging. Dependency Homepage License Usage com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.12.1 https://github.com/FasterXML/jackson Eclipse Public License 2.0 Reading YAML files ch.qos.logback:logback-classic:1.2.3 http://logback.qos.ch/ Logback License Logging org.apache.commons:commons-lang3:3.12:0 https://commons.apache.org/proper/commons-lang/ Apache License 2.0 Tool classes io.pebbletemplates:pebble:3.1.5 https://pebbletemplates.io/ Pebble License Template Engine org.codehaus.groovy:groovy:3.0.7 http://www.groovy-lang.org/ Apache 2.0 License Embedded Language for GroovyTask net.sf.saxon:Saxon-HE:10.5 http://www.saxonica.com/ MPL Version 2.0 XSL Transformation for XslTransformTask Build dependencies Those dependencies are required while building only. Dependency Homepage License Usage pl.project13.maven:git-commit-id-plugin:4.0.0 https://github.com/git-commit-id/git-commit-id-maven-plugin LGPL-3.0 License Providing Git Information for resource filtering org.apache.maven.plugins:maven-compiler-plugin:3.8.0 https://maven.apache.org/plugins/maven-compiler-plugin/ Apache License. 2.0 Compiling Java code org.apache.maven.plugins:maven-surefire-plugin:3.0.0-M5 https://maven.apache.org/surefire/maven-surefire-plugin/ Apache License. 2.0 Running tests org.jacoco:jacoco-maven-plugin:0.8.6 https://www.jacoco.org/jacoco/trunk/doc/maven.html EPL 2.0 Code coverage analysis org.apache.maven.plugins:maven-checkstyle-plugin:3.1.2 https://maven.apache.org/plugins/maven-checkstyle-plugin/ Apache License. 2.0 Static coded analysis com.github.spotbugs:spotbugs-maven-plugin:4.1.3 https://spotbugs.github.io/spotbugs-maven-plugin/ Apache License, 2.0 Static coded analysis org.apache.maven.plugins:maven-pmd-plugin:3.14.0 https://maven.apache.org/plugins/maven-dependency-plugin/ Apache License. 2.0 Static code analysis org.apache.maven.plugins:maven-shade-plugin:3.2.4 https://maven.apache.org/plugins/maven-shade-plugin/ Apache License. 2.0 All in one jar generator org.apache.maven.plugins:maven-javadoc-plugin:3.2.0 http://maven.apache.org/plugins/maven-javadoc-plugin/ Apache License. 2.0 API Documentation tool org.apache.maven.plugins:maven-dependency-plugin:3.1.2 https://maven.apache.org/plugins/maven-dependency-plugin/ Apache License. 2.0 Maven dependencies tool Test configuration The configuration of the surefire Maven plugin is the scope here: The configuration option <runOrder>random</runOrder> ensures that tests classes are running in random order. There is another very special configuration I don't like much but found it somewhere on the internet to handle the output on Console as well as the XML. They Junit5 guys did somehow a break in the format of the JUnit XML and you have to configure that it somehow works for current tools. Please don't ask me for details. Simply copy the configuration or leave it or find another solution on internet (I doubt you find much more than I habe found). Github actions It's surprisingly easy to organize a build for all three platforms and multiple Java versions with Github actions. The build is written in YAML format and is called workflow . Workflows have to be located at .github/workflows. The workflow for Hyperion is in the file .github/workflows/hyperion-build-actions.yml . Each time you push your changes remote the workflow automatically starts. The success is then visible by an success/failure icon on each location where the commit is shown. The history for all actions (including the currently running one) you can find here: https://github.com/thomas-lehmann-private/hyperion/actions . The file is really simple and the Github actions in general have good documentation. For the code coverage the usage is well documentated by the integration itself. The whole build is organized via a matrix build. All combinations of the values of the existing lists define one build job. When something goes wrong you can read the logs online at the individual build. Please note : The --batch-mode is really important to reduce the verbose output of the download operation for each single artefact. Jenkins You also can run your project locally via Jenkins. You simply create a pipelineline specifying the file url to your local repository. You shoudl have some plugins installed like Jacoco , Javadoc , AnsiColor , Built Timeout , Green Balls and Workspace Cleanup . The Jenkins job presents you out-of-the-box trend graphs for your tests, the code coverage and the static code analyses. Very awesome. The Jenkinsfile (default when you create a pipeline job) is given in the repository. I hope you agree: It's a small file. How to handle things In general violations will break the build, and the common expectation is that issues are correctly resolved. When a Jacoco error is raised it does mean that you have added coded without testing it. Decreasing the limit is not acceptable. When your code coverage does get better please increase those limits. When Checkstyle , PMD or Spotbug raise an error for src/main/java the expectation is to fix it without any suppression in 99% of all cases. For the 1% where you think you have to suppress it the reason has to be well documented. For some sort of error like magic numbers or repeated string literals happening in Unittests it's mostly ok when you use suppression. It should never happen that the code is overwhelmed with suppression. Interesting Links https://docs.github.com/en/actions https://github.com/actions/virtual-environments https://www.jenkins.io/doc/book/pipeline/syntax https://github.com/takari/maven-wrapper https://docs.github.com/en/actions/guides https://github.com/marketplace/actions/deploy-to-github-pages","title":"Build"},{"location":"internal/build/#build","text":"","title":"Build"},{"location":"internal/build/#quick-and-easy","text":"The build is organized with Maven. You don't have to install Maven because Maven Wrapper ( https://github.com/takari/maven-wrapper ) is used. On any system following command is sufficient as long as Java is given ( minimum Version : 11): ./mvnw On Unix based systems this is the exact filename of the script that is executed. On Windows it's the mvnw.cmd script (anyway you do not have to specify the extension that's why it looks and feel identical on all systems).","title":"Quick and easy"},{"location":"internal/build/#maven-profiles","text":"There are two profiles; one for Windows and one for Unix based systems. The main reason for two profiles is that the code coverage is different since not every test can be executed on every system (example: The UnixShellTaskTest can run on Unix based systems only). The reason to use a profile in general is to be able to define default goals, so you do not have to specify them on command line each time (convenience reason).","title":"Maven Profiles"},{"location":"internal/build/#default-goals","text":"The default goals are: clean package javadoc:jar verify clean - removes the target folder package - includes all previous goals like resource filtering, compiling and running tests. The package is combining the concrete jar with all dependencies into one jar that allows to use it standalone. javadoc:jar - generate the Javadoc HTML documentation and the javadoc jar. verify - is running all static code analysis (including the analysis of the code coverage).","title":"Default goals"},{"location":"internal/build/#maven-dependencies","text":"","title":"Maven Dependencies"},{"location":"internal/build/#test-dependencies","text":"Those dependencies are available only while testing. Dependency Homepage License Usage org.junit.jupiter:junit-jupiter-api:5.5.2 https://junit.org/junit5/ Eclipse Public License - v 2.0 Unittests org.junit.jupiter:junit-jupiter-engine:5.5.2 https://junit.org/junit5/ Eclipse Public License - v 2.0 Unittests org.junit.jupiter:junit-jupiter-params:5.5.2 https://junit.org/junit5/ Eclipse Public License - v 2.0 Unittests","title":"Test dependencies"},{"location":"internal/build/#runtime-dependencies","text":"Those dependencies are required at runtime and taken by the Maven shade plugin when packaging. Dependency Homepage License Usage com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.12.1 https://github.com/FasterXML/jackson Eclipse Public License 2.0 Reading YAML files ch.qos.logback:logback-classic:1.2.3 http://logback.qos.ch/ Logback License Logging org.apache.commons:commons-lang3:3.12:0 https://commons.apache.org/proper/commons-lang/ Apache License 2.0 Tool classes io.pebbletemplates:pebble:3.1.5 https://pebbletemplates.io/ Pebble License Template Engine org.codehaus.groovy:groovy:3.0.7 http://www.groovy-lang.org/ Apache 2.0 License Embedded Language for GroovyTask net.sf.saxon:Saxon-HE:10.5 http://www.saxonica.com/ MPL Version 2.0 XSL Transformation for XslTransformTask","title":"Runtime dependencies"},{"location":"internal/build/#build-dependencies","text":"Those dependencies are required while building only. Dependency Homepage License Usage pl.project13.maven:git-commit-id-plugin:4.0.0 https://github.com/git-commit-id/git-commit-id-maven-plugin LGPL-3.0 License Providing Git Information for resource filtering org.apache.maven.plugins:maven-compiler-plugin:3.8.0 https://maven.apache.org/plugins/maven-compiler-plugin/ Apache License. 2.0 Compiling Java code org.apache.maven.plugins:maven-surefire-plugin:3.0.0-M5 https://maven.apache.org/surefire/maven-surefire-plugin/ Apache License. 2.0 Running tests org.jacoco:jacoco-maven-plugin:0.8.6 https://www.jacoco.org/jacoco/trunk/doc/maven.html EPL 2.0 Code coverage analysis org.apache.maven.plugins:maven-checkstyle-plugin:3.1.2 https://maven.apache.org/plugins/maven-checkstyle-plugin/ Apache License. 2.0 Static coded analysis com.github.spotbugs:spotbugs-maven-plugin:4.1.3 https://spotbugs.github.io/spotbugs-maven-plugin/ Apache License, 2.0 Static coded analysis org.apache.maven.plugins:maven-pmd-plugin:3.14.0 https://maven.apache.org/plugins/maven-dependency-plugin/ Apache License. 2.0 Static code analysis org.apache.maven.plugins:maven-shade-plugin:3.2.4 https://maven.apache.org/plugins/maven-shade-plugin/ Apache License. 2.0 All in one jar generator org.apache.maven.plugins:maven-javadoc-plugin:3.2.0 http://maven.apache.org/plugins/maven-javadoc-plugin/ Apache License. 2.0 API Documentation tool org.apache.maven.plugins:maven-dependency-plugin:3.1.2 https://maven.apache.org/plugins/maven-dependency-plugin/ Apache License. 2.0 Maven dependencies tool","title":"Build dependencies"},{"location":"internal/build/#test-configuration","text":"The configuration of the surefire Maven plugin is the scope here: The configuration option <runOrder>random</runOrder> ensures that tests classes are running in random order. There is another very special configuration I don't like much but found it somewhere on the internet to handle the output on Console as well as the XML. They Junit5 guys did somehow a break in the format of the JUnit XML and you have to configure that it somehow works for current tools. Please don't ask me for details. Simply copy the configuration or leave it or find another solution on internet (I doubt you find much more than I habe found).","title":"Test configuration"},{"location":"internal/build/#github-actions","text":"It's surprisingly easy to organize a build for all three platforms and multiple Java versions with Github actions. The build is written in YAML format and is called workflow . Workflows have to be located at .github/workflows. The workflow for Hyperion is in the file .github/workflows/hyperion-build-actions.yml . Each time you push your changes remote the workflow automatically starts. The success is then visible by an success/failure icon on each location where the commit is shown. The history for all actions (including the currently running one) you can find here: https://github.com/thomas-lehmann-private/hyperion/actions . The file is really simple and the Github actions in general have good documentation. For the code coverage the usage is well documentated by the integration itself. The whole build is organized via a matrix build. All combinations of the values of the existing lists define one build job. When something goes wrong you can read the logs online at the individual build. Please note : The --batch-mode is really important to reduce the verbose output of the download operation for each single artefact.","title":"Github actions"},{"location":"internal/build/#jenkins","text":"You also can run your project locally via Jenkins. You simply create a pipelineline specifying the file url to your local repository. You shoudl have some plugins installed like Jacoco , Javadoc , AnsiColor , Built Timeout , Green Balls and Workspace Cleanup . The Jenkins job presents you out-of-the-box trend graphs for your tests, the code coverage and the static code analyses. Very awesome. The Jenkinsfile (default when you create a pipeline job) is given in the repository. I hope you agree: It's a small file.","title":"Jenkins"},{"location":"internal/build/#how-to-handle-things","text":"In general violations will break the build, and the common expectation is that issues are correctly resolved. When a Jacoco error is raised it does mean that you have added coded without testing it. Decreasing the limit is not acceptable. When your code coverage does get better please increase those limits. When Checkstyle , PMD or Spotbug raise an error for src/main/java the expectation is to fix it without any suppression in 99% of all cases. For the 1% where you think you have to suppress it the reason has to be well documented. For some sort of error like magic numbers or repeated string literals happening in Unittests it's mostly ok when you use suppression. It should never happen that the code is overwhelmed with suppression.","title":"How to handle things"},{"location":"internal/build/#interesting-links","text":"https://docs.github.com/en/actions https://github.com/actions/virtual-environments https://www.jenkins.io/doc/book/pipeline/syntax https://github.com/takari/maven-wrapper https://docs.github.com/en/actions/guides https://github.com/marketplace/actions/deploy-to-github-pages","title":"Interesting Links"},{"location":"internal/cli/","text":"CLI In future the code might move to an own individual respository. Nevertheless it should be documented how it works... Defining an option The creation of an option is best explained by an example: final var option = CliOption.builder() .setLongName(\"file\") .setShortName(\"f\") .setDescription(\"Provide document to process\") .setType(OptionType.STRING) .setRequired(true) .setRepeatable(false) .build(); The build() will throw an CliException when the validation of your definition has failed. Long names The field is required. A long name has to be lower case. You can combine as maximum three so called sub names namea-nameb-namec by dashes. Each subname has to start with a letter; then also numbers may be used (no other characters). it's not allowed to have less than 2 characters and no more than 15 characters. You can use the long name in two forms: --name=value --name value Short names The field is option (null or empty counts as not set). A short name can be upper case or lower case. You are allowed to define one character only (length equal to 1). You can use the short name in two forms: -v1234 -v 1234 Description The field is required It cannot be null and also not be empty The length may not exceed 40 characters. Keep in mind that this description should help the user. Repeatable The default is false (not repeatable). A repeatable option means that under given name a list of values is stored. The repeatable flag is shown in the help. Required The default is false (not required). A required field means that you have to specify the parameter. The required flag is shown in the help. Special scenario : consider a --help (which should be optional). If you (as an example) specify the option --file as required the CliParser will throw a CliException if you just use --help. You can define a command and with such an option (example: run). Only if you use that command you also have to specify the required option. Type The types are boolean, string, integer, double and path (for now). The default is string. The boolean means that you don't expect a value. The types are currently used for the help only to show what value is expected. Validation The build() function checks the rules as described before throwing a CliException when validation has failed. Defining a command The creation of a command is working pretty the same way as for the options. The definition of the command options is exactly the same thing. final var command = CliCommand.builder() .setName(\"run\") .setDescription(\"processing a document with tasks\") .addOption(fileOption) .build(); Name The name is required. The name should have at least two characters, and the length must not exceed 10 characters. The name has to be lower case. Description The field is required It cannot be null and also not be empty Option you can call addOption (several times) to add one option. you can call addAllOption (several times) to add a list of options. Validation The build() function checks the rules as described below throwing a CliException when validation has failed. checking for name and description checking for options a long name may exist once only a short name may exist once only a description may exist once only The option list The option list (CliOptionList) is special class keeping a list of options working with the builder options as already seen for the other classes. The build() function finally does also the validation: a long name may exist once only a short name may exist once only a description may exist once only These option list is required for the parser. Using the parser The parser does parse the command line arguments. final var parser = CliParser.builder() .setGlobalOptions(globalOptions) .setCommands(commands) .build(); final var result = parser.parse(arguments); Global options You set the list of global options (see option list - CliOptionList). Commands You have two options: using setCommands to set a list of commands (old commands are lost). using addCommand (several times) to add one command. Validation when parsing While parsing the command line arguments further validation is done: required options that are missing repeated options that are not defined repeatable if you use more than once command unknown options unknown commands Please note : You have to use global options before any command If you want to use required options don't use them on global options otherwise you run into problems when trying to use --help (as an example). Simply define a command for it. Using the result When the parsing is fine you get an instance of type CliResult and you three information are available then: with getGlobalOptions() you get a map where the key is the long name of the option the value is a list; if the option is repeatable it contains more than one value. same for getCommandOptions() . with getCommandName() you get the command. It's on you how you handle it. Help printer The setup of the help printer works similar as the parser. In addition to the defined options and commands you specify the execution, the product version, the build timestamp and the author: private void printHelp() throws CliException { final var helpPrinter = CliHelpPrinter.builder() .setExecution(\"java -jar \" + this.properties.getProperty(PROPERTY_FINAL_NAME) + \".jar\") .setProductVersion(this.properties.getProperty(PROPERTY_PRODUCT_VERSION)) .setBuildTimestamp(this.properties.getProperty(PROPERTY_BUILD_TIMESTAMP)) .setAuthor(this.properties.getProperty(PROPERTY_AUTHOR)) .setGlobalOptions(this.globalOptions) .setCommands(this.commands) .build(); helpPrinter.print(LoggerFactory.getLogger(\"HELP\")::info); } The code is extracted from the Hyperion application as I'm using it iself. With Maven and resource filtering I'm passing the information like the final name of the jar, the product version, the build timestamp and the author. For the logging I'm using a custom logger to avoid the usually timestamped output. At the time when I'm writing this documentation the result did look like following: java -jar hyperion-1.0.0-SNAPSHOT.jar [global options] [command [command options]] version: 1.0.0-SNAPSHOT, build timestamp: 2021-05-14 15:21 author: Thomas Lehmann <thomas.lehmann.private@gmail.com> Global options: -h, --help - displaying this help --third-party - displaying used 3rd party libraries List of available commands: run - Running one document with tasks to be processed Options for command 'run': -f<path>, --file=<path> - Document with tasks to be processed [required]","title":"CLI"},{"location":"internal/cli/#cli","text":"In future the code might move to an own individual respository. Nevertheless it should be documented how it works...","title":"CLI"},{"location":"internal/cli/#defining-an-option","text":"The creation of an option is best explained by an example: final var option = CliOption.builder() .setLongName(\"file\") .setShortName(\"f\") .setDescription(\"Provide document to process\") .setType(OptionType.STRING) .setRequired(true) .setRepeatable(false) .build(); The build() will throw an CliException when the validation of your definition has failed.","title":"Defining an option"},{"location":"internal/cli/#long-names","text":"The field is required. A long name has to be lower case. You can combine as maximum three so called sub names namea-nameb-namec by dashes. Each subname has to start with a letter; then also numbers may be used (no other characters). it's not allowed to have less than 2 characters and no more than 15 characters. You can use the long name in two forms: --name=value --name value","title":"Long names"},{"location":"internal/cli/#short-names","text":"The field is option (null or empty counts as not set). A short name can be upper case or lower case. You are allowed to define one character only (length equal to 1). You can use the short name in two forms: -v1234 -v 1234","title":"Short names"},{"location":"internal/cli/#description","text":"The field is required It cannot be null and also not be empty The length may not exceed 40 characters. Keep in mind that this description should help the user.","title":"Description"},{"location":"internal/cli/#repeatable","text":"The default is false (not repeatable). A repeatable option means that under given name a list of values is stored. The repeatable flag is shown in the help.","title":"Repeatable"},{"location":"internal/cli/#required","text":"The default is false (not required). A required field means that you have to specify the parameter. The required flag is shown in the help. Special scenario : consider a --help (which should be optional). If you (as an example) specify the option --file as required the CliParser will throw a CliException if you just use --help. You can define a command and with such an option (example: run). Only if you use that command you also have to specify the required option.","title":"Required"},{"location":"internal/cli/#type","text":"The types are boolean, string, integer, double and path (for now). The default is string. The boolean means that you don't expect a value. The types are currently used for the help only to show what value is expected.","title":"Type"},{"location":"internal/cli/#validation","text":"The build() function checks the rules as described before throwing a CliException when validation has failed.","title":"Validation"},{"location":"internal/cli/#defining-a-command","text":"The creation of a command is working pretty the same way as for the options. The definition of the command options is exactly the same thing. final var command = CliCommand.builder() .setName(\"run\") .setDescription(\"processing a document with tasks\") .addOption(fileOption) .build();","title":"Defining a command"},{"location":"internal/cli/#name","text":"The name is required. The name should have at least two characters, and the length must not exceed 10 characters. The name has to be lower case.","title":"Name"},{"location":"internal/cli/#description_1","text":"The field is required It cannot be null and also not be empty","title":"Description"},{"location":"internal/cli/#option","text":"you can call addOption (several times) to add one option. you can call addAllOption (several times) to add a list of options.","title":"Option"},{"location":"internal/cli/#validation_1","text":"The build() function checks the rules as described below throwing a CliException when validation has failed. checking for name and description checking for options a long name may exist once only a short name may exist once only a description may exist once only","title":"Validation"},{"location":"internal/cli/#the-option-list","text":"The option list (CliOptionList) is special class keeping a list of options working with the builder options as already seen for the other classes. The build() function finally does also the validation: a long name may exist once only a short name may exist once only a description may exist once only These option list is required for the parser.","title":"The option list"},{"location":"internal/cli/#using-the-parser","text":"The parser does parse the command line arguments. final var parser = CliParser.builder() .setGlobalOptions(globalOptions) .setCommands(commands) .build(); final var result = parser.parse(arguments);","title":"Using the parser"},{"location":"internal/cli/#global-options","text":"You set the list of global options (see option list - CliOptionList).","title":"Global options"},{"location":"internal/cli/#commands","text":"You have two options: using setCommands to set a list of commands (old commands are lost). using addCommand (several times) to add one command.","title":"Commands"},{"location":"internal/cli/#validation-when-parsing","text":"While parsing the command line arguments further validation is done: required options that are missing repeated options that are not defined repeatable if you use more than once command unknown options unknown commands Please note : You have to use global options before any command If you want to use required options don't use them on global options otherwise you run into problems when trying to use --help (as an example). Simply define a command for it.","title":"Validation when parsing"},{"location":"internal/cli/#using-the-result","text":"When the parsing is fine you get an instance of type CliResult and you three information are available then: with getGlobalOptions() you get a map where the key is the long name of the option the value is a list; if the option is repeatable it contains more than one value. same for getCommandOptions() . with getCommandName() you get the command. It's on you how you handle it.","title":"Using the result"},{"location":"internal/cli/#help-printer","text":"The setup of the help printer works similar as the parser. In addition to the defined options and commands you specify the execution, the product version, the build timestamp and the author: private void printHelp() throws CliException { final var helpPrinter = CliHelpPrinter.builder() .setExecution(\"java -jar \" + this.properties.getProperty(PROPERTY_FINAL_NAME) + \".jar\") .setProductVersion(this.properties.getProperty(PROPERTY_PRODUCT_VERSION)) .setBuildTimestamp(this.properties.getProperty(PROPERTY_BUILD_TIMESTAMP)) .setAuthor(this.properties.getProperty(PROPERTY_AUTHOR)) .setGlobalOptions(this.globalOptions) .setCommands(this.commands) .build(); helpPrinter.print(LoggerFactory.getLogger(\"HELP\")::info); } The code is extracted from the Hyperion application as I'm using it iself. With Maven and resource filtering I'm passing the information like the final name of the jar, the product version, the build timestamp and the author. For the logging I'm using a custom logger to avoid the usually timestamped output. At the time when I'm writing this documentation the result did look like following: java -jar hyperion-1.0.0-SNAPSHOT.jar [global options] [command [command options]] version: 1.0.0-SNAPSHOT, build timestamp: 2021-05-14 15:21 author: Thomas Lehmann <thomas.lehmann.private@gmail.com> Global options: -h, --help - displaying this help --third-party - displaying used 3rd party libraries List of available commands: run - Running one document with tasks to be processed Options for command 'run': -f<path>, --file=<path> - Document with tasks to be processed [required]","title":"Help printer"},{"location":"internal/finishing-a-milestone/","text":"Finishing a milestone Finishing a milestone is done in following phases: Phase 1 Review documentation it's the last chance to eventually add missing documentation. also looking for missing requirements. also looking for missing examples. Full local review on source code - it's the last chance to eventually fix things or to do small refactorings. Review code coverage - it's the last chance to eventually improve the code coverage. Phase 2 Changing the version to release a pom.xml modification. a modification in the workflow yaml for the release (hyperion-task-processor-release-action.yaml). it can be done without branch. Updating the github pages Tagging the repository with release version - it should trigger the related workflow that does also one build and finally publishing the artifacts on Github. Finish : - Announcing new version at here . - Also communicate that the next milestone is planned and already has stories. - Ask the community for interest in new features not yet in the milestone. - Closing the milestone.","title":"Finishing a milestone"},{"location":"internal/finishing-a-milestone/#finishing-a-milestone","text":"Finishing a milestone is done in following phases:","title":"Finishing a milestone"},{"location":"internal/finishing-a-milestone/#phase-1","text":"Review documentation it's the last chance to eventually add missing documentation. also looking for missing requirements. also looking for missing examples. Full local review on source code - it's the last chance to eventually fix things or to do small refactorings. Review code coverage - it's the last chance to eventually improve the code coverage.","title":"Phase 1"},{"location":"internal/finishing-a-milestone/#phase-2","text":"Changing the version to release a pom.xml modification. a modification in the workflow yaml for the release (hyperion-task-processor-release-action.yaml). it can be done without branch. Updating the github pages Tagging the repository with release version - it should trigger the related workflow that does also one build and finally publishing the artifacts on Github. Finish : - Announcing new version at here . - Also communicate that the next milestone is planned and already has stories. - Ask the community for interest in new features not yet in the milestone. - Closing the milestone.","title":"Phase 2"},{"location":"internal/implementing-a-new-task/","text":"Implementing a new task Introduction Writing a new task is getting easier by each new task because the given code offers more and more reusable functionality. That means you also have to rethink the design. In addition the static code analysis is a great help forcing you to rethink when duplicate code has been detected or one class does have to many dependencies to other classes. This article intends to explain how the DownloadTask has been implemented providing you an example. Overview The last graphic shows how the different classes are working together. For the download class following classes have to be implemented in that order: DownloadTask DownloadTaskCreator DownloadTaskReader DownloadTaskReaderCreator Required Constants For the different classes following enum classes have to be extended: TaskType - that enum has entries representing the type of task. The value of each enum reflects also the concrete value used in the YAML document for the type attribute. It is also used for the factory mechanism to find task creators and task reader creators. For the two creator classes and reader the enum DOWNLOAD has been added. DocumentReaderFields - that enum has entries representing the different attributes used in a YAML document. The value of each enum reflects the exact name to be used in the YAML document. It is used by the different reader to validate the document. For the DownloadTaskReader the enum URL has been added. Implementing the task For the concrete example the Download task is derived from the AbstractFileTask since there are multiple tasks sharing same attributes like: destination - mandatory string attribute - where to write the file to overwrite - optional boolean attribute - whether an existing file can be overwritten (default is false) ensure-path - optional boolean attribute - whether the destination path is created when missing (default is false) That's why for the DownloadTask just remains the mandatory attribute url . In general any task should now implement following methods: public TaskResult run(TaskParameters parameters) - the run Method is called by the task group which can run tasks in order or in parallel. The task parameters contain all data required to allow rendering a text with templating context like the document model (when a model has been defined), the current matrix attributes (when a matrix has been configured) the current task group variables (when variables are given) and the current with context (when list items have been defined at the task attribute with ). You simply can call parameters.getTemplatingContext()) to get the map that can be easily passed to the template engine. The download task allows rendering for the destination path only. Important is to call logTitle(parameters); because each task has a title (Component base class) allowing to see in the logs what task topic is handled. When something goes wrong the run method should define taskResult = new TaskResult(false, getVariable()); returning finally that task result; first parameter indicates the success of the task. When all is fine the task variable will be modified: getVariable().setValue(renderedDestinationPath.toString()); ; that way further tasks can continue working with the path and filename. For consistency all file based tasks should do that. Of course the task result should have true then as first parameter. public AbstractTask copy() - the copy is important for the situation where the user is using the with** attribute. The problem is here that the task is defined once but executed as often as many items are in the list. Since we can run tasks in order or in parallel this should also apply for that situation and related to the fact that we also then would have just one variable the task will be copied. public String toString() - the main purpose here is using it for the unit testing using a task for @Parameterized tests. Read here: Junit5 . In general provide reasonable logging that a user can see what is going on (especially when something goes wrong). Implementing the task creator The creator class is very easy and very small in its implementation. The main purpose are two things: The class implements public AbstractTask create() to provide a new instance of class DownloadTask . An annotation @Named(TaskType.Constants.DOWNLOAD) binds the creator to a concrete constant which is later on important for the factory . The Java SPI (Service Provider Interface) allows loading registered classed for a concrete interface. In this case for the ITaskCreator interface there is magic.systems.hyperion.components.tasks.creator.ITaskCreator file under src/main/resources/META-INF/services containing a flat list of classes implementing this interface. It necessary to add magic.system.hyperion.reader.creator.DownloadTaskReaderCreator there to allow the factory to find the creator by the name defined in the annotation. Implementing the task reader The reader basically is reading and validating information details from the YAML tree. The INodeReader provides the interface to accept the current node to be handled. All task based reader have two information passed from outside: the taskgroup : where to add the task that has been read and validated the task creator : interface to concrete task creator. You can rely on that the creator is compatible to the task; so you are allowed to cast to the concrete one. The class hierarchy offers you two functionalities: providing a matcher : with protected ListMatcher<String> getMatcher(final JsonNode node) you are able to implement on each level what fields (attributes) are mandatory and which ones are optional to be able to validate. Because the base class handled most things it just remains for the DownloadTaskReader to add following: matcher.requireExactlyOnce(DocumentReaderFields.URL.getFieldName()); . The matcher provides a matches method and when that one returns false you can stop reading throwing an exception (the YAML format is then wrong). providing basic read methods : with readBasic and readFile the base classes already initialize the task with the information found. For the DownloadTaskReader it remains to read and validate information for the URL and finally to add the task to the task group. Implementing the task reader creator It's very the same procedure as already explained for the task creator. The class implements public AbstractBasicTaskReader create() to provide a new instance of class DownloadTaskReader . The factory for tasks is used here to search for the concrete task creator passing it to the constructor of the reader. An annotation @Named(TaskType.Constants.DOWNLOAD) binds the creator to a concrete constant which is later on important for the factory . The Java SPI (Service Provider Interface) allows loading registered classed for a concrete interface. In this case for the ITaskReaderCreator interface there is magic.systems.hyperion.reader.creator.ITaskReaderCreator file under src/main/resources/META-INF/services containing a flat list of classes implementing this interface. It necessary to add magic.system.reader.creator.DownloadTaskReaderCreator there to allow the factory to find the creator by the name defined in the annotation. Testing Now all four classes are created you should be able to process documents with download tasks. Of course there should be unittests for the task and for the reader. For the reader it is sufficient to test it in context of reading a document. That's why I implemented following: DownloadTaskTest DocumentReaderForDownloadTaskTests","title":"Implementing a new task"},{"location":"internal/implementing-a-new-task/#implementing-a-new-task","text":"","title":"Implementing a new task"},{"location":"internal/implementing-a-new-task/#introduction","text":"Writing a new task is getting easier by each new task because the given code offers more and more reusable functionality. That means you also have to rethink the design. In addition the static code analysis is a great help forcing you to rethink when duplicate code has been detected or one class does have to many dependencies to other classes. This article intends to explain how the DownloadTask has been implemented providing you an example.","title":"Introduction"},{"location":"internal/implementing-a-new-task/#overview","text":"The last graphic shows how the different classes are working together. For the download class following classes have to be implemented in that order: DownloadTask DownloadTaskCreator DownloadTaskReader DownloadTaskReaderCreator","title":"Overview"},{"location":"internal/implementing-a-new-task/#required-constants","text":"For the different classes following enum classes have to be extended: TaskType - that enum has entries representing the type of task. The value of each enum reflects also the concrete value used in the YAML document for the type attribute. It is also used for the factory mechanism to find task creators and task reader creators. For the two creator classes and reader the enum DOWNLOAD has been added. DocumentReaderFields - that enum has entries representing the different attributes used in a YAML document. The value of each enum reflects the exact name to be used in the YAML document. It is used by the different reader to validate the document. For the DownloadTaskReader the enum URL has been added.","title":"Required Constants"},{"location":"internal/implementing-a-new-task/#implementing-the-task","text":"For the concrete example the Download task is derived from the AbstractFileTask since there are multiple tasks sharing same attributes like: destination - mandatory string attribute - where to write the file to overwrite - optional boolean attribute - whether an existing file can be overwritten (default is false) ensure-path - optional boolean attribute - whether the destination path is created when missing (default is false) That's why for the DownloadTask just remains the mandatory attribute url . In general any task should now implement following methods: public TaskResult run(TaskParameters parameters) - the run Method is called by the task group which can run tasks in order or in parallel. The task parameters contain all data required to allow rendering a text with templating context like the document model (when a model has been defined), the current matrix attributes (when a matrix has been configured) the current task group variables (when variables are given) and the current with context (when list items have been defined at the task attribute with ). You simply can call parameters.getTemplatingContext()) to get the map that can be easily passed to the template engine. The download task allows rendering for the destination path only. Important is to call logTitle(parameters); because each task has a title (Component base class) allowing to see in the logs what task topic is handled. When something goes wrong the run method should define taskResult = new TaskResult(false, getVariable()); returning finally that task result; first parameter indicates the success of the task. When all is fine the task variable will be modified: getVariable().setValue(renderedDestinationPath.toString()); ; that way further tasks can continue working with the path and filename. For consistency all file based tasks should do that. Of course the task result should have true then as first parameter. public AbstractTask copy() - the copy is important for the situation where the user is using the with** attribute. The problem is here that the task is defined once but executed as often as many items are in the list. Since we can run tasks in order or in parallel this should also apply for that situation and related to the fact that we also then would have just one variable the task will be copied. public String toString() - the main purpose here is using it for the unit testing using a task for @Parameterized tests. Read here: Junit5 . In general provide reasonable logging that a user can see what is going on (especially when something goes wrong).","title":"Implementing the task"},{"location":"internal/implementing-a-new-task/#implementing-the-task-creator","text":"The creator class is very easy and very small in its implementation. The main purpose are two things: The class implements public AbstractTask create() to provide a new instance of class DownloadTask . An annotation @Named(TaskType.Constants.DOWNLOAD) binds the creator to a concrete constant which is later on important for the factory . The Java SPI (Service Provider Interface) allows loading registered classed for a concrete interface. In this case for the ITaskCreator interface there is magic.systems.hyperion.components.tasks.creator.ITaskCreator file under src/main/resources/META-INF/services containing a flat list of classes implementing this interface. It necessary to add magic.system.hyperion.reader.creator.DownloadTaskReaderCreator there to allow the factory to find the creator by the name defined in the annotation.","title":"Implementing the task creator"},{"location":"internal/implementing-a-new-task/#implementing-the-task-reader","text":"The reader basically is reading and validating information details from the YAML tree. The INodeReader provides the interface to accept the current node to be handled. All task based reader have two information passed from outside: the taskgroup : where to add the task that has been read and validated the task creator : interface to concrete task creator. You can rely on that the creator is compatible to the task; so you are allowed to cast to the concrete one. The class hierarchy offers you two functionalities: providing a matcher : with protected ListMatcher<String> getMatcher(final JsonNode node) you are able to implement on each level what fields (attributes) are mandatory and which ones are optional to be able to validate. Because the base class handled most things it just remains for the DownloadTaskReader to add following: matcher.requireExactlyOnce(DocumentReaderFields.URL.getFieldName()); . The matcher provides a matches method and when that one returns false you can stop reading throwing an exception (the YAML format is then wrong). providing basic read methods : with readBasic and readFile the base classes already initialize the task with the information found. For the DownloadTaskReader it remains to read and validate information for the URL and finally to add the task to the task group.","title":"Implementing the task reader"},{"location":"internal/implementing-a-new-task/#implementing-the-task-reader-creator","text":"It's very the same procedure as already explained for the task creator. The class implements public AbstractBasicTaskReader create() to provide a new instance of class DownloadTaskReader . The factory for tasks is used here to search for the concrete task creator passing it to the constructor of the reader. An annotation @Named(TaskType.Constants.DOWNLOAD) binds the creator to a concrete constant which is later on important for the factory . The Java SPI (Service Provider Interface) allows loading registered classed for a concrete interface. In this case for the ITaskReaderCreator interface there is magic.systems.hyperion.reader.creator.ITaskReaderCreator file under src/main/resources/META-INF/services containing a flat list of classes implementing this interface. It necessary to add magic.system.reader.creator.DownloadTaskReaderCreator there to allow the factory to find the creator by the name defined in the annotation.","title":"Implementing the task reader creator"},{"location":"internal/implementing-a-new-task/#testing","text":"Now all four classes are created you should be able to process documents with download tasks. Of course there should be unittests for the task and for the reader. For the reader it is sufficient to test it in context of reading a document. That's why I implemented following: DownloadTaskTest DocumentReaderForDownloadTaskTests","title":"Testing"},{"location":"internal/junit5/","text":"JUnit5 The setup of Junit5 is explained here: Build . Default test methods There is not much to say since the annotation @Test is the same as for Junit4. However one fact is important: If you use @ParameterizedTest you cannot use @Test . Assertions The assertions of Junit5 are a lot to feel comfortable; after here some of them I have used: Assertion Meaning Context assertEquals Comparing two things to be equal values assertNotEquals Comparing two things to be unequal values assertTrue Verify that a condition evaluates to true condition/state assertFalse Verify that a condition evaluates to false condition/state assertNull Verify that an instance of something is null instance assertNotNull Verify that an instance of something is not null instance assertThrows Verify that a concrete exception has been thrown exception assertDoesNotThrow Verify that no exception is thrown. exception assumeTrue When condition is false the test is marked as ignored run/ignore test Note Each variant is provided a second one where you can provide a helpful message that is shown when the assertion is thrown. Note The assertThrows also provides the throwable that you additional can verify that the concrete message is thrown or whatever information you have passed to your exception. Parameterized tests Parameterized tests are a nice way to write a test method once calling it several times for different data input. In the list of tests each variant appears individually given you a clear idea which of the variant has failed. /** * Testing validation of the long name. * * @param bExpectedToFail when true then expected to fail. * @param strValue value for long name. * @param strMessage hint for the case the assertion does fail. */ @ParameterizedTest( name = \"test long name - #{index} expected to fail={0}, value={1}, message={2}\") @MethodSource(\"provideLongNameValidationTestData\") public void testLongNameValidation( final boolean bExpectedToFail, final String strValue, final String strMessage) { // setup of builder final var builder = CliOption.builder(); builder.setShortName(\"x\"); builder.setDescription(\"test\"); builder.setLongName(strValue); if (bExpectedToFail) { assertThrows(CliException.class, builder::build, strMessage); } else { assertDoesNotThrow(builder::build, strMessage); } } The given code is taken from Hyperion and you can see following: The annotation @ParametrerizedTest with the name value specifying how the test is displayed in the IDE. The curly braces are substituted by the values passes as parameters to the test function. The {index} is a special parameter to allow the visualize the nth call of the test method. The annotation @MethodSource is to specify a static method that does provide the test data. For being able to control how the assertion should work a boolean is passed as well telling the method what kind of assertion is wanted. In given example there is an exception thrown when the test is expected to fail otherwise it will be verified that no exception is thrown when test is expected to succeed. Note It's to say that the visualization of the parameterized test does not necessarily work on all IDE. That's why I have been switching to Intellij where it is working well. Note The annotation @DisplayName doesn't work well in the IDE (for now) on the test method; that's why I did place a name in front of the index. However it has to be placed on the class otherwise the Maven build shows null instead of the class name. The following code is the relating function providing the test data: /** * Test data for long name validation. * * @return test data. */ private static Stream<Arguments> provideLongNameValidationTestData() { //CHECKSTYLE.OFF: MultipleStringLiterals - ok here. return Stream.of( Arguments.of(true, null, \"cannot be null\"), Arguments.of(true, \"FILE\", \"cannot be uppercase letters\"), Arguments.of(true, \"f\", \"too short\"), Arguments.of(true, \"abcdefghijklmnop\", \"too long\"), Arguments.of(false, \"abcdefghijklmno\", \"maximum length for one subname\"), Arguments.of(false, \"config-file\", \"two valid sub names\"), Arguments.of(false, \"config-file-path\", \"three valid sub names\"), Arguments.of(true, \"the-config-file-path\", \"limited to three sub names\"), Arguments.of(true, \"abcdefghijklmno-abcdefghijklmnop\", \"second subname too long\"), Arguments.of(true, \"abcdefghijklmno-a\", \"second subname too short\"), Arguments.of(true, \"abcdefghijklmno-abcdefghijklmno-abcdefghijklmnop\", \"third subname too long\"), Arguments.of(true, \"abcdefghijklmno-abcdefghijklmno-a\", \"third subname too short\"), Arguments.of(false, \"http2\", \"allows number at the end\"), Arguments.of(true, \"2http\", \"name cannot start with numbers\"), Arguments.of(false, \"ht2tp\", \"allows numbers in name\"), Arguments.of(true, \"abc!?-_[](),;.\", \"cannot be special characters\") ); //CHECKSTYLE.ON: MultipleStringLiterals } Following information should be recognized: The function is - of course - private and it must be static . The return value is a Stream ! The function does return a Stream() something. Each entry enforces a call of the test method and the parameters for one call are Arguments.of() something. You don't need to but I organized to have the explaining message as one parameter. It appears in the list of tests as parameters as well as it is shown for the case that the test does fail because the message is passed to the. How it looks like in an IDE Assuming You might have the problem that a test depends on a certain setup of the system. Let's say you do not have Docker installed on your system then this test detects that and the concrete assertion will automatically mark the tests as ignored. @Test public void testDockerForTargetUnix() { assumeTrue(Capabilities.hasDocker()); // test code } OS specific tests There are test that can run on specific systems only. JUnit5 is capable to detect the system and you can use the annotation @EnabledOnOs to specify on which system the test should run. @DisplayName(\"Testing UnixShellTask\") @EnabledOnOs({OS.LINUX, OS.MAC}) public class UnixShellTaskTest { // test code } and @DisplayName(\"Testing WindowsBatchTask\") @EnabledOnOs(OS.WINDOWS) public class WindowsBatchTaskTest { // test code } Code Coverage Also explained in Build the awareness should here be raised that unit tests running on multiple environments and multiple platforms might lead to multiple coverage results. On Windows the class UnixShellTask is not tested (as an example). There for you can organize a profile which - at least - allows you to have different coverage limits depending on the platform. Order of test methods It's not obvious but there is an algorithm defining an order. However tests should be independent and therefor a random order is probably a better solution: @DisplayName(\"Testing of CliOption class\") @TestMethodOrder(value = MethodOrderer.Random.class) public class CliOptionTest { // test code } Please note When a test fails the logging prints the seed that has been used to run the methods in random order that you are able to re-run the tests in same order when the problem did arrive. You have to set the property junit.jupiter.execution.order.random.seed then. It's also possible to define random order of test classes. That can be defined in the pom.xml at the surefire Maven plugin with the configuration option <runOrder>random</runOrder> .","title":"JUnit5"},{"location":"internal/junit5/#junit5","text":"The setup of Junit5 is explained here: Build .","title":"JUnit5"},{"location":"internal/junit5/#default-test-methods","text":"There is not much to say since the annotation @Test is the same as for Junit4. However one fact is important: If you use @ParameterizedTest you cannot use @Test .","title":"Default test methods"},{"location":"internal/junit5/#assertions","text":"The assertions of Junit5 are a lot to feel comfortable; after here some of them I have used: Assertion Meaning Context assertEquals Comparing two things to be equal values assertNotEquals Comparing two things to be unequal values assertTrue Verify that a condition evaluates to true condition/state assertFalse Verify that a condition evaluates to false condition/state assertNull Verify that an instance of something is null instance assertNotNull Verify that an instance of something is not null instance assertThrows Verify that a concrete exception has been thrown exception assertDoesNotThrow Verify that no exception is thrown. exception assumeTrue When condition is false the test is marked as ignored run/ignore test Note Each variant is provided a second one where you can provide a helpful message that is shown when the assertion is thrown. Note The assertThrows also provides the throwable that you additional can verify that the concrete message is thrown or whatever information you have passed to your exception.","title":"Assertions"},{"location":"internal/junit5/#parameterized-tests","text":"Parameterized tests are a nice way to write a test method once calling it several times for different data input. In the list of tests each variant appears individually given you a clear idea which of the variant has failed. /** * Testing validation of the long name. * * @param bExpectedToFail when true then expected to fail. * @param strValue value for long name. * @param strMessage hint for the case the assertion does fail. */ @ParameterizedTest( name = \"test long name - #{index} expected to fail={0}, value={1}, message={2}\") @MethodSource(\"provideLongNameValidationTestData\") public void testLongNameValidation( final boolean bExpectedToFail, final String strValue, final String strMessage) { // setup of builder final var builder = CliOption.builder(); builder.setShortName(\"x\"); builder.setDescription(\"test\"); builder.setLongName(strValue); if (bExpectedToFail) { assertThrows(CliException.class, builder::build, strMessage); } else { assertDoesNotThrow(builder::build, strMessage); } } The given code is taken from Hyperion and you can see following: The annotation @ParametrerizedTest with the name value specifying how the test is displayed in the IDE. The curly braces are substituted by the values passes as parameters to the test function. The {index} is a special parameter to allow the visualize the nth call of the test method. The annotation @MethodSource is to specify a static method that does provide the test data. For being able to control how the assertion should work a boolean is passed as well telling the method what kind of assertion is wanted. In given example there is an exception thrown when the test is expected to fail otherwise it will be verified that no exception is thrown when test is expected to succeed. Note It's to say that the visualization of the parameterized test does not necessarily work on all IDE. That's why I have been switching to Intellij where it is working well. Note The annotation @DisplayName doesn't work well in the IDE (for now) on the test method; that's why I did place a name in front of the index. However it has to be placed on the class otherwise the Maven build shows null instead of the class name. The following code is the relating function providing the test data: /** * Test data for long name validation. * * @return test data. */ private static Stream<Arguments> provideLongNameValidationTestData() { //CHECKSTYLE.OFF: MultipleStringLiterals - ok here. return Stream.of( Arguments.of(true, null, \"cannot be null\"), Arguments.of(true, \"FILE\", \"cannot be uppercase letters\"), Arguments.of(true, \"f\", \"too short\"), Arguments.of(true, \"abcdefghijklmnop\", \"too long\"), Arguments.of(false, \"abcdefghijklmno\", \"maximum length for one subname\"), Arguments.of(false, \"config-file\", \"two valid sub names\"), Arguments.of(false, \"config-file-path\", \"three valid sub names\"), Arguments.of(true, \"the-config-file-path\", \"limited to three sub names\"), Arguments.of(true, \"abcdefghijklmno-abcdefghijklmnop\", \"second subname too long\"), Arguments.of(true, \"abcdefghijklmno-a\", \"second subname too short\"), Arguments.of(true, \"abcdefghijklmno-abcdefghijklmno-abcdefghijklmnop\", \"third subname too long\"), Arguments.of(true, \"abcdefghijklmno-abcdefghijklmno-a\", \"third subname too short\"), Arguments.of(false, \"http2\", \"allows number at the end\"), Arguments.of(true, \"2http\", \"name cannot start with numbers\"), Arguments.of(false, \"ht2tp\", \"allows numbers in name\"), Arguments.of(true, \"abc!?-_[](),;.\", \"cannot be special characters\") ); //CHECKSTYLE.ON: MultipleStringLiterals } Following information should be recognized: The function is - of course - private and it must be static . The return value is a Stream ! The function does return a Stream() something. Each entry enforces a call of the test method and the parameters for one call are Arguments.of() something. You don't need to but I organized to have the explaining message as one parameter. It appears in the list of tests as parameters as well as it is shown for the case that the test does fail because the message is passed to the.","title":"Parameterized tests"},{"location":"internal/junit5/#how-it-looks-like-in-an-ide","text":"","title":"How it looks like in an IDE"},{"location":"internal/junit5/#assuming","text":"You might have the problem that a test depends on a certain setup of the system. Let's say you do not have Docker installed on your system then this test detects that and the concrete assertion will automatically mark the tests as ignored. @Test public void testDockerForTargetUnix() { assumeTrue(Capabilities.hasDocker()); // test code }","title":"Assuming"},{"location":"internal/junit5/#os-specific-tests","text":"There are test that can run on specific systems only. JUnit5 is capable to detect the system and you can use the annotation @EnabledOnOs to specify on which system the test should run. @DisplayName(\"Testing UnixShellTask\") @EnabledOnOs({OS.LINUX, OS.MAC}) public class UnixShellTaskTest { // test code } and @DisplayName(\"Testing WindowsBatchTask\") @EnabledOnOs(OS.WINDOWS) public class WindowsBatchTaskTest { // test code }","title":"OS specific tests"},{"location":"internal/junit5/#code-coverage","text":"Also explained in Build the awareness should here be raised that unit tests running on multiple environments and multiple platforms might lead to multiple coverage results. On Windows the class UnixShellTask is not tested (as an example). There for you can organize a profile which - at least - allows you to have different coverage limits depending on the platform.","title":"Code Coverage"},{"location":"internal/junit5/#order-of-test-methods","text":"It's not obvious but there is an algorithm defining an order. However tests should be independent and therefor a random order is probably a better solution: @DisplayName(\"Testing of CliOption class\") @TestMethodOrder(value = MethodOrderer.Random.class) public class CliOptionTest { // test code } Please note When a test fails the logging prints the seed that has been used to run the methods in random order that you are able to re-run the tests in same order when the problem did arrive. You have to set the property junit.jupiter.execution.order.random.seed then. It's also possible to define random order of test classes. That can be defined in the pom.xml at the surefire Maven plugin with the configuration option <runOrder>random</runOrder> .","title":"Order of test methods"},{"location":"internal/mkdocs/","text":"Mkdocs Installation It requires Python. pip install mkdocs mkdocs-bootswatch mkdocs-graphviz pymdown-extensions mkdocs-mermaid2-plugin mkdocs-autolinks-plugin Configuration The configuration of the project is defined in the mkdocs.yml in the root of the repository. At the top you define the meta data of the project like name of the project author of the project Url of the Github pages where these site will be located later on The url of the Github repository. In the middle section you define the navigation: With Home the main page is define which you see first. With Index you get a menu \"Index\" in the top bar and all sub menu items are those ones listed unter the index entry. At the bottom there are two sections: theme is for the look and feel. Therefore the mkdocs-bootswatch is needed. markdown_extensions are markdown extensions for rendering: mkdocs_graphviz is for rendering Graphviz syntax as SVG. admonition is for special note boxes. footnotes allows writing footnotes 1 pymdownx.tilde for strikethrough with ~~strikethrough~~ pymdownx.caret pymdownx.mark for marked with ==marked== pymdownx.magiclink for auto creation of links used in markdown code. plugins for plugins like: mkdocs-mermaid2-plugin for rendering Mermaid diagrams. mkdocs-autolinks-plugin for autolink that you don't have to worry about paths. Graphviz Example Following simple example (you have to add dot behind the first three backticks): ``` digraph D { A -> B; } ``` produces Special note boxes Please Note Some note. You have to choose the right indent Attention Some warning. Please don't ... Problem You are in trouble if ... generated by !!! note \"Please Note\" Some note. You have to choose the right indent !!! warning \"Attention\" Some warning. Please don't ... !!! error \"Problem\" You are in trouble if ... Mermaid example graph LR; A--> B & C & D; B--> A & E; C--> A & E; D--> A & E; E--> B & C & D; generated by ```mermaid graph LR; A--> B & C & D; B--> A & E; C--> A & E; D--> A & E; E--> B & C & D; ``` Testing It does build the site and after that you can open your browser at http://localhost:8000 to see the result. Changes to known Markdown files will be recognized, so you just have to refresh your Browser to see the results. mkdocs serve Deploying Later on it should be done automatically via Github workflow with a Github action but for now I'm doing it on a gh-pages branch manually by copying the content of the site folder - generates by mkdocs build - into that branch. Links https://gitlab.com/rodrigo.schwencke/mkdocs-graphviz https://squidfunk.github.io/mkdocs-material/reference/admonitions https://squidfunk.github.io/mkdocs-material/reference/footnotes/ https://facelessuser.github.io/pymdown-extensions/extensions/magiclink/ This is footnote one \u21a9","title":"Mkdocs"},{"location":"internal/mkdocs/#mkdocs","text":"","title":"Mkdocs"},{"location":"internal/mkdocs/#installation","text":"It requires Python. pip install mkdocs mkdocs-bootswatch mkdocs-graphviz pymdown-extensions mkdocs-mermaid2-plugin mkdocs-autolinks-plugin","title":"Installation"},{"location":"internal/mkdocs/#configuration","text":"The configuration of the project is defined in the mkdocs.yml in the root of the repository. At the top you define the meta data of the project like name of the project author of the project Url of the Github pages where these site will be located later on The url of the Github repository. In the middle section you define the navigation: With Home the main page is define which you see first. With Index you get a menu \"Index\" in the top bar and all sub menu items are those ones listed unter the index entry. At the bottom there are two sections: theme is for the look and feel. Therefore the mkdocs-bootswatch is needed. markdown_extensions are markdown extensions for rendering: mkdocs_graphviz is for rendering Graphviz syntax as SVG. admonition is for special note boxes. footnotes allows writing footnotes 1 pymdownx.tilde for strikethrough with ~~strikethrough~~ pymdownx.caret pymdownx.mark for marked with ==marked== pymdownx.magiclink for auto creation of links used in markdown code. plugins for plugins like: mkdocs-mermaid2-plugin for rendering Mermaid diagrams. mkdocs-autolinks-plugin for autolink that you don't have to worry about paths.","title":"Configuration"},{"location":"internal/mkdocs/#graphviz-example","text":"Following simple example (you have to add dot behind the first three backticks): ``` digraph D { A -> B; } ``` produces","title":"Graphviz Example"},{"location":"internal/mkdocs/#special-note-boxes","text":"Please Note Some note. You have to choose the right indent Attention Some warning. Please don't ... Problem You are in trouble if ... generated by !!! note \"Please Note\" Some note. You have to choose the right indent !!! warning \"Attention\" Some warning. Please don't ... !!! error \"Problem\" You are in trouble if ...","title":"Special note boxes"},{"location":"internal/mkdocs/#mermaid-example","text":"graph LR; A--> B & C & D; B--> A & E; C--> A & E; D--> A & E; E--> B & C & D; generated by ```mermaid graph LR; A--> B & C & D; B--> A & E; C--> A & E; D--> A & E; E--> B & C & D; ```","title":"Mermaid example"},{"location":"internal/mkdocs/#testing","text":"It does build the site and after that you can open your browser at http://localhost:8000 to see the result. Changes to known Markdown files will be recognized, so you just have to refresh your Browser to see the results. mkdocs serve","title":"Testing"},{"location":"internal/mkdocs/#deploying","text":"Later on it should be done automatically via Github workflow with a Github action but for now I'm doing it on a gh-pages branch manually by copying the content of the site folder - generates by mkdocs build - into that branch.","title":"Deploying"},{"location":"internal/mkdocs/#links","text":"https://gitlab.com/rodrigo.schwencke/mkdocs-graphviz https://squidfunk.github.io/mkdocs-material/reference/admonitions https://squidfunk.github.io/mkdocs-material/reference/footnotes/ https://facelessuser.github.io/pymdown-extensions/extensions/magiclink/ This is footnote one \u21a9","title":"Links"},{"location":"requirements/req-printing%20capabilities%20to%20console/","text":"Printing capabilities to console Document meta data Type : Requirement Id : 3 Context : system information Milestone : 1.0.0 Description As a devops engineer I want to verify which capabilities for the Hyperion tool are given. Constraints No constraints. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Printing capabilities to console"},{"location":"requirements/req-printing%20capabilities%20to%20console/#printing-capabilities-to-console","text":"","title":"Printing capabilities to console"},{"location":"requirements/req-printing%20capabilities%20to%20console/#document-meta-data","text":"Type : Requirement Id : 3 Context : system information Milestone : 1.0.0","title":"Document meta data"},{"location":"requirements/req-printing%20capabilities%20to%20console/#description","text":"As a devops engineer I want to verify which capabilities for the Hyperion tool are given.","title":"Description"},{"location":"requirements/req-printing%20capabilities%20to%20console/#constraints","text":"No constraints.","title":"Constraints"},{"location":"requirements/req-printing%20capabilities%20to%20console/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-provide%20%27with%27%20attribute%20on%20tasks%20allowing%20to%20repeat%20same%20task%20for%20each%20entry%20in%20the%20list/","text":"Provide 'with' attribute on tasks allowing to repeat same task for each entry in the list Document meta data Type : Requirement Id : 5 Context : task feature Milestone : 1.0.0 Description As a devops engineer you want to be able to define a list of entries that any task is repeated for each entry. You can use templating to access current list entry. Each list entry can be one of: - a simple value - a map of something The map works as the model. A map can have key/value and the value might be: a simple value a map of something a list of something Each value will be rendered (see templating ) Each entry might be different in its structure (if you prefer). The tool does not check (validate) for this so you have take care in the templating logic then. Constraints No constraints. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Provide 'with' attribute on tasks allowing to repeat same task for each entry in the list"},{"location":"requirements/req-provide%20%27with%27%20attribute%20on%20tasks%20allowing%20to%20repeat%20same%20task%20for%20each%20entry%20in%20the%20list/#provide-with-attribute-on-tasks-allowing-to-repeat-same-task-for-each-entry-in-the-list","text":"","title":"Provide 'with' attribute on tasks allowing to repeat same task for each entry in the list"},{"location":"requirements/req-provide%20%27with%27%20attribute%20on%20tasks%20allowing%20to%20repeat%20same%20task%20for%20each%20entry%20in%20the%20list/#document-meta-data","text":"Type : Requirement Id : 5 Context : task feature Milestone : 1.0.0","title":"Document meta data"},{"location":"requirements/req-provide%20%27with%27%20attribute%20on%20tasks%20allowing%20to%20repeat%20same%20task%20for%20each%20entry%20in%20the%20list/#description","text":"As a devops engineer you want to be able to define a list of entries that any task is repeated for each entry. You can use templating to access current list entry. Each list entry can be one of: - a simple value - a map of something The map works as the model. A map can have key/value and the value might be: a simple value a map of something a list of something Each value will be rendered (see templating ) Each entry might be different in its structure (if you prefer). The tool does not check (validate) for this so you have take care in the templating logic then.","title":"Description"},{"location":"requirements/req-provide%20%27with%27%20attribute%20on%20tasks%20allowing%20to%20repeat%20same%20task%20for%20each%20entry%20in%20the%20list/#constraints","text":"No constraints.","title":"Constraints"},{"location":"requirements/req-provide%20%27with%27%20attribute%20on%20tasks%20allowing%20to%20repeat%20same%20task%20for%20each%20entry%20in%20the%20list/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-provide%20a%20docker%20container%20task/","text":"Provide a Docker container task Document meta data Type : Requirement Id : 11 Context : task feature Milestone : 1.0.0 Description As a devops engineer you should be able to create a docker container by a task. The script code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task with additional following parameters: image-name - required parameter. It's the name of the Docker image. image-version - optional parameter. It's the version of the Docker image. If not specified the default version is 'latest'. platform - optional parameter. The default is 'unix'. On Windows you also can use Docker to run so called Windows container. For the moment you can use use the one or the other only by switching manually to the platform you prefer. There's an experimental option in Docker allowing you to specify the platform on command line to run both but - since it is experimental - it is not yet supported by the task. The Docker container runs in foreground mode. When the process has finished the Docker container is automatically removed. The current working path is mapped into the Docker container as /work. Constraints Docker is required to be installed, running and the command should be in the search path. You have to choose manually which platform to use: Unix or Windows container. No ports are published to outside the moment. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Provide a Docker container task"},{"location":"requirements/req-provide%20a%20docker%20container%20task/#provide-a-docker-container-task","text":"","title":"Provide a Docker container task"},{"location":"requirements/req-provide%20a%20docker%20container%20task/#document-meta-data","text":"Type : Requirement Id : 11 Context : task feature Milestone : 1.0.0","title":"Document meta data"},{"location":"requirements/req-provide%20a%20docker%20container%20task/#description","text":"As a devops engineer you should be able to create a docker container by a task. The script code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task with additional following parameters: image-name - required parameter. It's the name of the Docker image. image-version - optional parameter. It's the version of the Docker image. If not specified the default version is 'latest'. platform - optional parameter. The default is 'unix'. On Windows you also can use Docker to run so called Windows container. For the moment you can use use the one or the other only by switching manually to the platform you prefer. There's an experimental option in Docker allowing you to specify the platform on command line to run both but - since it is experimental - it is not yet supported by the task. The Docker container runs in foreground mode. When the process has finished the Docker container is automatically removed. The current working path is mapped into the Docker container as /work.","title":"Description"},{"location":"requirements/req-provide%20a%20docker%20container%20task/#constraints","text":"Docker is required to be installed, running and the command should be in the search path. You have to choose manually which platform to use: Unix or Windows container. No ports are published to outside the moment.","title":"Constraints"},{"location":"requirements/req-provide%20a%20docker%20container%20task/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-provide%20a%20download%20task/","text":"Provide a download task Document meta data Type : Requirement Id : 14 Context : file task feature Milestone : 2.0.0 Description As a devops engineer you should be able to write content to a file. The standard parameters are those of a basic task with additional following parameters: url - required parameter with a valid url where to download the file from. destination - required parameter with path and filename where to write the content. overwrite - optional boolean attribute allowing you to overwrite the destination file when the file exists. The default should be false; then the task operation should fail when the destination path exists. ensure-path - optional boolean attribute ensuring that the destination path does exist. The default should be false; then the task operation should fail when the path doesn't exist . Constraints url end point must be reachable and file to download must exist. the file operation depends on the permissions given on the file system. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Provide a download task"},{"location":"requirements/req-provide%20a%20download%20task/#provide-a-download-task","text":"","title":"Provide a download task"},{"location":"requirements/req-provide%20a%20download%20task/#document-meta-data","text":"Type : Requirement Id : 14 Context : file task feature Milestone : 2.0.0","title":"Document meta data"},{"location":"requirements/req-provide%20a%20download%20task/#description","text":"As a devops engineer you should be able to write content to a file. The standard parameters are those of a basic task with additional following parameters: url - required parameter with a valid url where to download the file from. destination - required parameter with path and filename where to write the content. overwrite - optional boolean attribute allowing you to overwrite the destination file when the file exists. The default should be false; then the task operation should fail when the destination path exists. ensure-path - optional boolean attribute ensuring that the destination path does exist. The default should be false; then the task operation should fail when the path doesn't exist .","title":"Description"},{"location":"requirements/req-provide%20a%20download%20task/#constraints","text":"url end point must be reachable and file to download must exist. the file operation depends on the permissions given on the file system.","title":"Constraints"},{"location":"requirements/req-provide%20a%20download%20task/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-provide%20coded%20tasks/","text":"Provide coded tasks Document meta data Type : Requirement Id : 1 Context : task feature Milestone : 1.0.0 Description As devops engineer you should be able to write coded tasks with following standard parameters: title - the title of the task being logged code - the concrete code to be executed or the path or filename of the script (depends on implementation of concrete task). Templating is supported on this attribute. variable - optional to define how the stdout is captured (default is to capture all) tags - optional a list of strings to allow filtering for concrete tasks Variable the name attribute that can be addressed in other tasks using templating. (the default name is \" default \") the regex attribute represent the Java regex to define what to captured from stdout. (the default is to capture all) the group attribute is an integer to define which regex group to use. (the default regex group is 0) the linbebyline attribute is a boolean. When true the regex is applied on each single line to allow filtering otherwise the regex is applied on the whole output (default is false) Constraints No constraints. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Provide coded tasks"},{"location":"requirements/req-provide%20coded%20tasks/#provide-coded-tasks","text":"","title":"Provide coded tasks"},{"location":"requirements/req-provide%20coded%20tasks/#document-meta-data","text":"Type : Requirement Id : 1 Context : task feature Milestone : 1.0.0","title":"Document meta data"},{"location":"requirements/req-provide%20coded%20tasks/#description","text":"As devops engineer you should be able to write coded tasks with following standard parameters: title - the title of the task being logged code - the concrete code to be executed or the path or filename of the script (depends on implementation of concrete task). Templating is supported on this attribute. variable - optional to define how the stdout is captured (default is to capture all) tags - optional a list of strings to allow filtering for concrete tasks","title":"Description"},{"location":"requirements/req-provide%20coded%20tasks/#variable","text":"the name attribute that can be addressed in other tasks using templating. (the default name is \" default \") the regex attribute represent the Java regex to define what to captured from stdout. (the default is to capture all) the group attribute is an integer to define which regex group to use. (the default regex group is 0) the linbebyline attribute is a boolean. When true the regex is applied on each single line to allow filtering otherwise the regex is applied on the whole output (default is false)","title":"Variable"},{"location":"requirements/req-provide%20coded%20tasks/#constraints","text":"No constraints.","title":"Constraints"},{"location":"requirements/req-provide%20coded%20tasks/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-provide%20groovy%20task/","text":"Provide Groovy task Document meta data Type : Requirement Id : 9 Context : task feature Milestone : 1.0.0 Description As a devops engineer you should be able to write a Groovy script as task. The script code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task. Constraints No constraints. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Provide Groovy task"},{"location":"requirements/req-provide%20groovy%20task/#provide-groovy-task","text":"","title":"Provide Groovy task"},{"location":"requirements/req-provide%20groovy%20task/#document-meta-data","text":"Type : Requirement Id : 9 Context : task feature Milestone : 1.0.0","title":"Document meta data"},{"location":"requirements/req-provide%20groovy%20task/#description","text":"As a devops engineer you should be able to write a Groovy script as task. The script code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task.","title":"Description"},{"location":"requirements/req-provide%20groovy%20task/#constraints","text":"No constraints.","title":"Constraints"},{"location":"requirements/req-provide%20groovy%20task/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-provide%20jshell%20task/","text":"Provide JShell task Document meta data Type : Requirement Id : 10 Context : task feature Milestone : 1.0.0 Description As a devops engineer you should be able to write a JShell script as task. The standard parameters are those of a coded task. Constraints The script code can be embedded only. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Provide JShell task"},{"location":"requirements/req-provide%20jshell%20task/#provide-jshell-task","text":"","title":"Provide JShell task"},{"location":"requirements/req-provide%20jshell%20task/#document-meta-data","text":"Type : Requirement Id : 10 Context : task feature Milestone : 1.0.0","title":"Document meta data"},{"location":"requirements/req-provide%20jshell%20task/#description","text":"As a devops engineer you should be able to write a JShell script as task. The standard parameters are those of a coded task.","title":"Description"},{"location":"requirements/req-provide%20jshell%20task/#constraints","text":"The script code can be embedded only.","title":"Constraints"},{"location":"requirements/req-provide%20jshell%20task/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-provide%20powershell%20task/","text":"Provide Powershell task Document meta data Type : Requirement Id : 2 Context : task feature Milestone : 1.0.0 Description As a devops engineer you should be able to write a Powershell script as task. The Powershell code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task. Constraints The task is supposed to run on Windows systems only (the moment). Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Provide Powershell task"},{"location":"requirements/req-provide%20powershell%20task/#provide-powershell-task","text":"","title":"Provide Powershell task"},{"location":"requirements/req-provide%20powershell%20task/#document-meta-data","text":"Type : Requirement Id : 2 Context : task feature Milestone : 1.0.0","title":"Document meta data"},{"location":"requirements/req-provide%20powershell%20task/#description","text":"As a devops engineer you should be able to write a Powershell script as task. The Powershell code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task.","title":"Description"},{"location":"requirements/req-provide%20powershell%20task/#constraints","text":"The task is supposed to run on Windows systems only (the moment).","title":"Constraints"},{"location":"requirements/req-provide%20powershell%20task/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-provide%20unix%20shell%20task/","text":"Provide unix shell task Document meta data Type : Requirement Id : 8 Context : task feature Milestone : 1.0.0 Description As a devops engineer you should be able to write a Unix shell script as task. The script code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task. Constraints The task is supposed to run on Unix systems only. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Provide unix shell task"},{"location":"requirements/req-provide%20unix%20shell%20task/#provide-unix-shell-task","text":"","title":"Provide unix shell task"},{"location":"requirements/req-provide%20unix%20shell%20task/#document-meta-data","text":"Type : Requirement Id : 8 Context : task feature Milestone : 1.0.0","title":"Document meta data"},{"location":"requirements/req-provide%20unix%20shell%20task/#description","text":"As a devops engineer you should be able to write a Unix shell script as task. The script code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task.","title":"Description"},{"location":"requirements/req-provide%20unix%20shell%20task/#constraints","text":"The task is supposed to run on Unix systems only.","title":"Constraints"},{"location":"requirements/req-provide%20unix%20shell%20task/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-provide%20windows%20batch%20task/","text":"Provide windows batch task Document meta data Type : Requirement Id : 7 Context : task feature Milestone : 1.0.0 Description As a devops engineer you should be able to write a windows batch script as task. The Batch code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task. Constraints The task is supposed to run on Windows systems only. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Provide windows batch task"},{"location":"requirements/req-provide%20windows%20batch%20task/#provide-windows-batch-task","text":"","title":"Provide windows batch task"},{"location":"requirements/req-provide%20windows%20batch%20task/#document-meta-data","text":"Type : Requirement Id : 7 Context : task feature Milestone : 1.0.0","title":"Document meta data"},{"location":"requirements/req-provide%20windows%20batch%20task/#description","text":"As a devops engineer you should be able to write a windows batch script as task. The Batch code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task.","title":"Description"},{"location":"requirements/req-provide%20windows%20batch%20task/#constraints","text":"The task is supposed to run on Windows systems only.","title":"Constraints"},{"location":"requirements/req-provide%20windows%20batch%20task/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-provide%20write%20to%20file%20task/","text":"Provide write to file task Document meta data Type : Requirement Id : 13 Context : task feature Milestone : 2.0.0 Description As a devops engineer you should be able to write content to a file. The standard parameters are those of a basic task with additional following parameters: content - required parameter with some embedded content (not a file). Templating should be supported on this attribute. destination - required parameter with path and filename where to write the content. overwrite - optional boolean attribute allowing you to overwrite the destination file when the file exists. The default should be false; then the task operation should fail when the destination path exists. ensure-path - optional boolean attribute ensuring that the destination path does exist. The default should be false; then the task operation should fail when the path doesn't exist . Constraints the file operation depends on the permissions given on the file system. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion task processing tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Provide write to file task"},{"location":"requirements/req-provide%20write%20to%20file%20task/#provide-write-to-file-task","text":"","title":"Provide write to file task"},{"location":"requirements/req-provide%20write%20to%20file%20task/#document-meta-data","text":"Type : Requirement Id : 13 Context : task feature Milestone : 2.0.0","title":"Document meta data"},{"location":"requirements/req-provide%20write%20to%20file%20task/#description","text":"As a devops engineer you should be able to write content to a file. The standard parameters are those of a basic task with additional following parameters: content - required parameter with some embedded content (not a file). Templating should be supported on this attribute. destination - required parameter with path and filename where to write the content. overwrite - optional boolean attribute allowing you to overwrite the destination file when the file exists. The default should be false; then the task operation should fail when the destination path exists. ensure-path - optional boolean attribute ensuring that the destination path does exist. The default should be false; then the task operation should fail when the path doesn't exist .","title":"Description"},{"location":"requirements/req-provide%20write%20to%20file%20task/#constraints","text":"the file operation depends on the permissions given on the file system.","title":"Constraints"},{"location":"requirements/req-provide%20write%20to%20file%20task/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion task processing tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-provide%20xslt%20task/","text":"Provide xslt task Document meta data Type : Requirement Id : 12 Context : task feature Milestone : 2.0.0 Description As a devops engineer you should be able to write a xslt script as task. It basically requires two attributes: xsl - the transformation script (embedded or as path and filename). The attribute is required. Templating is supported on this attribute. xml - the XML content to transform (embedded or as path and filename). The attribute is required. Templating is supported on this attribute. The result of the transformation is written into the variable. XSLT 3.0 should be supported. Constraints XSLT 3.0 is supported Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Provide xslt task"},{"location":"requirements/req-provide%20xslt%20task/#provide-xslt-task","text":"","title":"Provide xslt task"},{"location":"requirements/req-provide%20xslt%20task/#document-meta-data","text":"Type : Requirement Id : 12 Context : task feature Milestone : 2.0.0","title":"Document meta data"},{"location":"requirements/req-provide%20xslt%20task/#description","text":"As a devops engineer you should be able to write a xslt script as task. It basically requires two attributes: xsl - the transformation script (embedded or as path and filename). The attribute is required. Templating is supported on this attribute. xml - the XML content to transform (embedded or as path and filename). The attribute is required. Templating is supported on this attribute. The result of the transformation is written into the variable. XSLT 3.0 should be supported.","title":"Description"},{"location":"requirements/req-provide%20xslt%20task/#constraints","text":"XSLT 3.0 is supported","title":"Constraints"},{"location":"requirements/req-provide%20xslt%20task/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-providing%20a%20copy%20file%20task/","text":"providing a copy file task Document meta data Type : Requirement Id : 6 Context : task feature Milestone : 1.0.0 Description As a devops engineer you should be able to copy a file from source to destination. The standard parameters are those of a basic task with additional following parameters: source - the source location of a file that must exist. The attribute is required. Templating is supported on this attribute. destination - the destination location of a file. The attribute is required. Templating is supported on this attribute. overwrite - optional boolean attribute allowing you to overwrite the destination file when the file exists. The default should be false; when the destination path exists the task operation should fail. ensure-path - optional boolean attribute ensuring that the destination path does exist. The default should be false; when the path doesn't exist the task operation should fail. destination-is-directory - optional boolean attribute telling the task how to interpret the value defined in the attribute \"destination\". The default is set to true; the filename of the source is then appended to the destination. Constraints the file operation depends on the permissions given on the file system. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"providing a copy file task"},{"location":"requirements/req-providing%20a%20copy%20file%20task/#providing-a-copy-file-task","text":"","title":"providing a copy file task"},{"location":"requirements/req-providing%20a%20copy%20file%20task/#document-meta-data","text":"Type : Requirement Id : 6 Context : task feature Milestone : 1.0.0","title":"Document meta data"},{"location":"requirements/req-providing%20a%20copy%20file%20task/#description","text":"As a devops engineer you should be able to copy a file from source to destination. The standard parameters are those of a basic task with additional following parameters: source - the source location of a file that must exist. The attribute is required. Templating is supported on this attribute. destination - the destination location of a file. The attribute is required. Templating is supported on this attribute. overwrite - optional boolean attribute allowing you to overwrite the destination file when the file exists. The default should be false; when the destination path exists the task operation should fail. ensure-path - optional boolean attribute ensuring that the destination path does exist. The default should be false; when the path doesn't exist the task operation should fail. destination-is-directory - optional boolean attribute telling the task how to interpret the value defined in the attribute \"destination\". The default is set to true; the filename of the source is then appended to the destination.","title":"Description"},{"location":"requirements/req-providing%20a%20copy%20file%20task/#constraints","text":"the file operation depends on the permissions given on the file system.","title":"Constraints"},{"location":"requirements/req-providing%20a%20copy%20file%20task/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-providing%20a%20docker%20image%20task/","text":"Providing a Docker image task Document meta data Type : Requirement Id : 4 Context : task feature Milestone : 1.0.0 Description As a devops engineer you should be able to create a docker image by a task. The Dockerfile code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task with additional following parameters: repository-tag - for details please read the external documentation (see links). Constraints Docker is required to be installed, running and the command should be in the search path. Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future. Dependencies Provide coded tasks External Documentation https://docs.docker.com/engine/reference/builder/ https://docs.docker.com/engine/reference/commandline/tag/","title":"Providing a Docker image task"},{"location":"requirements/req-providing%20a%20docker%20image%20task/#providing-a-docker-image-task","text":"","title":"Providing a Docker image task"},{"location":"requirements/req-providing%20a%20docker%20image%20task/#document-meta-data","text":"Type : Requirement Id : 4 Context : task feature Milestone : 1.0.0","title":"Document meta data"},{"location":"requirements/req-providing%20a%20docker%20image%20task/#description","text":"As a devops engineer you should be able to create a docker image by a task. The Dockerfile code can be embedded in the document or referencing a valid path and filename. The standard parameters are those of a coded task with additional following parameters: repository-tag - for details please read the external documentation (see links).","title":"Description"},{"location":"requirements/req-providing%20a%20docker%20image%20task/#constraints","text":"Docker is required to be installed, running and the command should be in the search path.","title":"Constraints"},{"location":"requirements/req-providing%20a%20docker%20image%20task/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"},{"location":"requirements/req-providing%20a%20docker%20image%20task/#dependencies","text":"Provide coded tasks","title":"Dependencies"},{"location":"requirements/req-providing%20a%20docker%20image%20task/#external-documentation","text":"https://docs.docker.com/engine/reference/builder/ https://docs.docker.com/engine/reference/commandline/tag/","title":"External Documentation"},{"location":"requirements/req-run%20docker%20container%20in%20detached%20mode/","text":"Run docker container in detached mode Document meta data Type : Requirement Id : 15 Context : docker task feature Milestone : 2.0.0 Description As a devops engineer you should be able to run a docker container in detached mode. There the optional boolean attribute detached should be available, defaulted to false . Constraints See Provde a docker container task . Criticality and Risk Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Run docker container in detached mode"},{"location":"requirements/req-run%20docker%20container%20in%20detached%20mode/#run-docker-container-in-detached-mode","text":"","title":"Run docker container in detached mode"},{"location":"requirements/req-run%20docker%20container%20in%20detached%20mode/#document-meta-data","text":"Type : Requirement Id : 15 Context : docker task feature Milestone : 2.0.0","title":"Document meta data"},{"location":"requirements/req-run%20docker%20container%20in%20detached%20mode/#description","text":"As a devops engineer you should be able to run a docker container in detached mode. There the optional boolean attribute detached should be available, defaulted to false .","title":"Description"},{"location":"requirements/req-run%20docker%20container%20in%20detached%20mode/#constraints","text":"See Provde a docker container task .","title":"Constraints"},{"location":"requirements/req-run%20docker%20container%20in%20detached%20mode/#criticality-and-risk","text":"Warning The possibility of something going wrong, and the associated consequences of failure, are highly dependent on the user of the Hyperion tool, as using the tool requires that the results be verified in a test environment. There is a risk that the user will be blocked in his work if the tool does not work properly, but there is no guarantee due to the license. Nevertheless, the author is extremely interested in correcting all reported errors in the near future.","title":"Criticality and Risk"}]}