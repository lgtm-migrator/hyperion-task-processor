{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Hyperion The special task processing tool Main goals For the main goals and the current progress please have a look at current Milestone 1.0.0 . You can see there which issues are closed and which ones are in the queue. The list of open issues is not necessarily complete, it means there might be further features added to that milestone. Status The tool is not yet production ready. I cannot tell you a release date the moment, but I'm constantly developing on it in my free time. The current issue(s) I'm working on are pinned and can be seen at the top of the issue list. Issues If you are using the tool and find things please report an issue but please check before that the issue isn't already there. The issue tracker is here . Please do not assign tags (please leave that to me). Thank you. Please also provide concrete examples that I'm able to reproduce the problem. Documentation The current documentation will be here . Have a look at the top menu under menu entry Index . As mentioned the tool is not yet production ready - so please be patient - there will be detailed documentation and examples.","title":"Home"},{"location":"#welcome-to-hyperion","text":"The special task processing tool","title":"Welcome to Hyperion"},{"location":"#main-goals","text":"For the main goals and the current progress please have a look at current Milestone 1.0.0 . You can see there which issues are closed and which ones are in the queue. The list of open issues is not necessarily complete, it means there might be further features added to that milestone.","title":"Main goals"},{"location":"#status","text":"The tool is not yet production ready. I cannot tell you a release date the moment, but I'm constantly developing on it in my free time. The current issue(s) I'm working on are pinned and can be seen at the top of the issue list.","title":"Status"},{"location":"#issues","text":"If you are using the tool and find things please report an issue but please check before that the issue isn't already there. The issue tracker is here . Please do not assign tags (please leave that to me). Thank you. Please also provide concrete examples that I'm able to reproduce the problem.","title":"Issues"},{"location":"#documentation","text":"The current documentation will be here . Have a look at the top menu under menu entry Index . As mentioned the tool is not yet production ready - so please be patient - there will be detailed documentation and examples.","title":"Documentation"},{"location":"cli/","text":"CLI In future the code might move to an own individual respository. Nevertheless it should be documented how it works... Defining an option The creation of an option is best explained by an example: final var option = CliOption.builder() .setLongName(\"file\") .setShortName(\"f\") .setDescription(\"Provide document to process\") .setType(OptionType.STRING) .setRequired(true) .setRepeatable(false) .build(); The build() will throw an CliException when the validation of your definition has failed. Long names The field is required. A long name has to be lower case. You can combine as maximum three so called sub names namea-nameb-namec by dashes. Each subname has to start with a letter; then also numbers may be used (no other characters). it's not allowed to have less than 2 characters and no more than 15 characters. You can use the long name in two forms: --name=value --name value Short names The field is option (null or empty counts as not set). A short name can be upper case or lower case. You are allowed to define one character only (length equal to 1). You can use the short name in two forms: -v1234 -v 1234 Description The field is required It cannot be null and also not be empty The length may not exceed 40 characters. Keep in mind that this description should help the user. Repeatable The default is false (not repeatable). A repeatable option means that under given name a list of values is stored. The repeatable flag is shown in the help. Required The default is false (not required). A required field means that you have to specify the parameter. The required flag is shown in the help. Special scenario : consider a --help (which should be optional). If you (as an example) specify the option --file as required the CliParser will throw a CliException if you just use --help. You can define a command and with such an option (example: run). Only if you use that command you also have to specify the required option. Type The types are boolean, string, integer, double and path (for now). The default is string. The boolean means that you don't expect a value. The types are currently used for the help only to show what value is expected. Validation The build() function checks the rules as described before throwing a CliException when validation has failed. Defining a command The creation of a command is working pretty the same way as for the options. The definition of the command options is exactly the same thing. final var command = CliCommand.builder() .setName(\"run\") .setDescription(\"processing a document with tasks\") .addOption(fileOption) .build(); Name The name is required. The name should have at least two characters, and the length must not exceed 10 characters. The name has to be lower case. Description The field is required It cannot be null and also not be empty Option you can call addOption (several times) to add one option. you can call addAllOption (several times) to add a list of options. Validation The build() function checks the rules as described below throwing a CliException when validation has failed. checking for name and description checking for options a long name may exist once only a short name may exist once only a description may exist once only The option list The option list (CliOptionList) is special class keeping a list of options working with the builder options as already seen for the other classes. The build() function finally does also the validation: a long name may exist once only a short name may exist once only a description may exist once only These option list is required for the parser. Using the parser The parser does parse the command line arguments. final var parser = CliParser.builder() .setGlobalOptions(globalOptions) .setCommands(commands) .build(); final var result = parser.parse(arguments); Global options You set the list of global options (see option list - CliOptionList). Commands You have two options: using setCommands to set a list of commands (old commands are lost). using addCommand (several times) to add one command. Validation when parsing While parsing the command line arguments further validation is done: required options that are missing repeated options that are not defined repeatable if you use more than once command unknown options unknown commands Please note : You have to use global options before any command If you want to use required options don't use them on global options otherwise you run into problems when trying to use --help (as an example). Simply define a command for it. Using the result When the parsing is fine you get an instance of type CliResult and you three information are available then: with getGlobalOptions() you get a map where the key is the long name of the option the value is a list; if the option is repeatable it contains more than one value. same for getCommandOptions() . with getCommandName() you get the command. It's on you how you handle it. Help printer The setup of the help printer works similar as the parser. In addition to the defined options and commands you specify the execution, the product version, the build timestamp and the author: private void printHelp() throws CliException { final var helpPrinter = CliHelpPrinter.builder() .setExecution(\"java -jar \" + this.properties.getProperty(PROPERTY_FINAL_NAME) + \".jar\") .setProductVersion(this.properties.getProperty(PROPERTY_PRODUCT_VERSION)) .setBuildTimestamp(this.properties.getProperty(PROPERTY_BUILD_TIMESTAMP)) .setAuthor(this.properties.getProperty(PROPERTY_AUTHOR)) .setGlobalOptions(this.globalOptions) .setCommands(this.commands) .build(); helpPrinter.print(LoggerFactory.getLogger(\"HELP\")::info); } The code is extracted from the Hyperion application as I'm using it iself. With Maven and resource filtering I'm passing the information like the final name of the jar, the product version, the build timestamp and the author. For the logging I'm using a custom logger to avoid the usually timestamped output. At the time when I'm writing this documentation the result did look like following: java -jar hyperion-1.0.0-SNAPSHOT.jar [global options] [command [command options]] version: 1.0.0-SNAPSHOT, build timestamp: 2021-05-14 15:21 author: Thomas Lehmann <thomas.lehmann.private@gmail.com> Global options: -h, --help - displaying this help --third-party - displaying used 3rd party libraries List of available commands: run - Running one document with tasks to be processed Options for command 'run': -f<path>, --file=<path> - Document with tasks to be processed [required]","title":"CLI"},{"location":"cli/#cli","text":"In future the code might move to an own individual respository. Nevertheless it should be documented how it works...","title":"CLI"},{"location":"cli/#defining-an-option","text":"The creation of an option is best explained by an example: final var option = CliOption.builder() .setLongName(\"file\") .setShortName(\"f\") .setDescription(\"Provide document to process\") .setType(OptionType.STRING) .setRequired(true) .setRepeatable(false) .build(); The build() will throw an CliException when the validation of your definition has failed.","title":"Defining an option"},{"location":"cli/#long-names","text":"The field is required. A long name has to be lower case. You can combine as maximum three so called sub names namea-nameb-namec by dashes. Each subname has to start with a letter; then also numbers may be used (no other characters). it's not allowed to have less than 2 characters and no more than 15 characters. You can use the long name in two forms: --name=value --name value","title":"Long names"},{"location":"cli/#short-names","text":"The field is option (null or empty counts as not set). A short name can be upper case or lower case. You are allowed to define one character only (length equal to 1). You can use the short name in two forms: -v1234 -v 1234","title":"Short names"},{"location":"cli/#description","text":"The field is required It cannot be null and also not be empty The length may not exceed 40 characters. Keep in mind that this description should help the user.","title":"Description"},{"location":"cli/#repeatable","text":"The default is false (not repeatable). A repeatable option means that under given name a list of values is stored. The repeatable flag is shown in the help.","title":"Repeatable"},{"location":"cli/#required","text":"The default is false (not required). A required field means that you have to specify the parameter. The required flag is shown in the help. Special scenario : consider a --help (which should be optional). If you (as an example) specify the option --file as required the CliParser will throw a CliException if you just use --help. You can define a command and with such an option (example: run). Only if you use that command you also have to specify the required option.","title":"Required"},{"location":"cli/#type","text":"The types are boolean, string, integer, double and path (for now). The default is string. The boolean means that you don't expect a value. The types are currently used for the help only to show what value is expected.","title":"Type"},{"location":"cli/#validation","text":"The build() function checks the rules as described before throwing a CliException when validation has failed.","title":"Validation"},{"location":"cli/#defining-a-command","text":"The creation of a command is working pretty the same way as for the options. The definition of the command options is exactly the same thing. final var command = CliCommand.builder() .setName(\"run\") .setDescription(\"processing a document with tasks\") .addOption(fileOption) .build();","title":"Defining a command"},{"location":"cli/#name","text":"The name is required. The name should have at least two characters, and the length must not exceed 10 characters. The name has to be lower case.","title":"Name"},{"location":"cli/#description_1","text":"The field is required It cannot be null and also not be empty","title":"Description"},{"location":"cli/#option","text":"you can call addOption (several times) to add one option. you can call addAllOption (several times) to add a list of options.","title":"Option"},{"location":"cli/#validation_1","text":"The build() function checks the rules as described below throwing a CliException when validation has failed. checking for name and description checking for options a long name may exist once only a short name may exist once only a description may exist once only","title":"Validation"},{"location":"cli/#the-option-list","text":"The option list (CliOptionList) is special class keeping a list of options working with the builder options as already seen for the other classes. The build() function finally does also the validation: a long name may exist once only a short name may exist once only a description may exist once only These option list is required for the parser.","title":"The option list"},{"location":"cli/#using-the-parser","text":"The parser does parse the command line arguments. final var parser = CliParser.builder() .setGlobalOptions(globalOptions) .setCommands(commands) .build(); final var result = parser.parse(arguments);","title":"Using the parser"},{"location":"cli/#global-options","text":"You set the list of global options (see option list - CliOptionList).","title":"Global options"},{"location":"cli/#commands","text":"You have two options: using setCommands to set a list of commands (old commands are lost). using addCommand (several times) to add one command.","title":"Commands"},{"location":"cli/#validation-when-parsing","text":"While parsing the command line arguments further validation is done: required options that are missing repeated options that are not defined repeatable if you use more than once command unknown options unknown commands Please note : You have to use global options before any command If you want to use required options don't use them on global options otherwise you run into problems when trying to use --help (as an example). Simply define a command for it.","title":"Validation when parsing"},{"location":"cli/#using-the-result","text":"When the parsing is fine you get an instance of type CliResult and you three information are available then: with getGlobalOptions() you get a map where the key is the long name of the option the value is a list; if the option is repeatable it contains more than one value. same for getCommandOptions() . with getCommandName() you get the command. It's on you how you handle it.","title":"Using the result"},{"location":"cli/#help-printer","text":"The setup of the help printer works similar as the parser. In addition to the defined options and commands you specify the execution, the product version, the build timestamp and the author: private void printHelp() throws CliException { final var helpPrinter = CliHelpPrinter.builder() .setExecution(\"java -jar \" + this.properties.getProperty(PROPERTY_FINAL_NAME) + \".jar\") .setProductVersion(this.properties.getProperty(PROPERTY_PRODUCT_VERSION)) .setBuildTimestamp(this.properties.getProperty(PROPERTY_BUILD_TIMESTAMP)) .setAuthor(this.properties.getProperty(PROPERTY_AUTHOR)) .setGlobalOptions(this.globalOptions) .setCommands(this.commands) .build(); helpPrinter.print(LoggerFactory.getLogger(\"HELP\")::info); } The code is extracted from the Hyperion application as I'm using it iself. With Maven and resource filtering I'm passing the information like the final name of the jar, the product version, the build timestamp and the author. For the logging I'm using a custom logger to avoid the usually timestamped output. At the time when I'm writing this documentation the result did look like following: java -jar hyperion-1.0.0-SNAPSHOT.jar [global options] [command [command options]] version: 1.0.0-SNAPSHOT, build timestamp: 2021-05-14 15:21 author: Thomas Lehmann <thomas.lehmann.private@gmail.com> Global options: -h, --help - displaying this help --third-party - displaying used 3rd party libraries List of available commands: run - Running one document with tasks to be processed Options for command 'run': -f<path>, --file=<path> - Document with tasks to be processed [required]","title":"Help printer"},{"location":"groovy/","text":"Groovy task This page doesn't intend to explain Groovy. So please refer to official Groovy documentation for details on it. It's about the Groovy task. Minimal example The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: groovy code: println 'hello world!' Minimal example with tags The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: groovy code: println 'hello world!' tags: - simple - example Example with variable The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: groovy title: a simple example code: println '---> this is a demo <---' variable: name: test2 regex: \">(.*)<\" group: 1 Example with templating The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: groovy title: a simple example 1 code: println 'hello world!' - type: groovy title: a simple example 2 code: println '{{ variables.default.value }}' In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: groovy title: a simple example 1 code: println '{{ model.attributest.description }}' The rules on how to access the individual elements of a model are explained here .","title":"Groovy task"},{"location":"groovy/#groovy-task","text":"This page doesn't intend to explain Groovy. So please refer to official Groovy documentation for details on it. It's about the Groovy task.","title":"Groovy task"},{"location":"groovy/#minimal-example","text":"The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: groovy code: println 'hello world!'","title":"Minimal example"},{"location":"groovy/#minimal-example-with-tags","text":"The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: groovy code: println 'hello world!' tags: - simple - example","title":"Minimal example with tags"},{"location":"groovy/#example-with-variable","text":"The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: groovy title: a simple example code: println '---> this is a demo <---' variable: name: test2 regex: \">(.*)<\" group: 1","title":"Example with variable"},{"location":"groovy/#example-with-templating","text":"The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: groovy title: a simple example 1 code: println 'hello world!' - type: groovy title: a simple example 2 code: println '{{ variables.default.value }}' In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: groovy title: a simple example 1 code: println '{{ model.attributest.description }}' The rules on how to access the individual elements of a model are explained here .","title":"Example with templating"},{"location":"hyperion/","text":"Application Introduction The hyperion tool allows processing a YAML document with tasks. There can be many tasks like: Powershell (functional on Windows only) Batch (functional on Windows only) Groovy (all platforms because: embedded) JShell (all platforms because: embedded) That's the current list and will be updated when new tasks will be added. Command line interface The current command line options look like following: java -jar hyperion-1.0.0-SNAPSHOT.jar [global options] [command [command options]] version: 1.0.0-SNAPSHOT, build timestamp: 2021-05-20 03:48 author: Thomas Lehmann <thomas.lehmann.private@gmail.com> Global options: -h, --help - displaying this help --third-party - displaying used 3rd party libraries -t<str>, --tag=<str> - provide tag to filter tasks [repeatable] List of available commands: run - Running one document with tasks to be processed Options for command 'run': -f<path>, --file=<path> - Document with tasks to be processed [required] Also those help should be good enough to help on usage here a few notes: if you use --help you get the help. However, if you would also specify the command \"run\" you are forced to specify the path of the document too. Global options have to be specified before a command otherwise options would be interpreted as option related to a command and --help would be unknown then. You can specify one command only. Specifying a tag all tasks will run that have that tag only. Tasks with other tags or even without tags will be ignored.","title":"Application"},{"location":"hyperion/#application","text":"","title":"Application"},{"location":"hyperion/#introduction","text":"The hyperion tool allows processing a YAML document with tasks. There can be many tasks like: Powershell (functional on Windows only) Batch (functional on Windows only) Groovy (all platforms because: embedded) JShell (all platforms because: embedded) That's the current list and will be updated when new tasks will be added.","title":"Introduction"},{"location":"hyperion/#command-line-interface","text":"The current command line options look like following: java -jar hyperion-1.0.0-SNAPSHOT.jar [global options] [command [command options]] version: 1.0.0-SNAPSHOT, build timestamp: 2021-05-20 03:48 author: Thomas Lehmann <thomas.lehmann.private@gmail.com> Global options: -h, --help - displaying this help --third-party - displaying used 3rd party libraries -t<str>, --tag=<str> - provide tag to filter tasks [repeatable] List of available commands: run - Running one document with tasks to be processed Options for command 'run': -f<path>, --file=<path> - Document with tasks to be processed [required] Also those help should be good enough to help on usage here a few notes: if you use --help you get the help. However, if you would also specify the command \"run\" you are forced to specify the path of the document too. Global options have to be specified before a command otherwise options would be interpreted as option related to a command and --help would be unknown then. You can specify one command only. Specifying a tag all tasks will run that have that tag only. Tasks with other tags or even without tags will be ignored.","title":"Command line interface"},{"location":"shell/","text":"Shell task This page doesn't intend to explain Unix shell. So please refer to official Unix shell documentation for details on it. It's about the Unix shell task. Minimal example The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: shell code: echo \"hello world!\" Minimal example with tags The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: shell code: echo \"hello world!\" tags: - simple - example Example with variable The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: shell title: a simple example code: echo \"---> this is a demo <---\" variable: name: test2 regex: \">(.*)<\" group: 1 Example with templating The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: shell title: a simple example 1 code: echo \"hello world!\" - type: shell title: a simple example 2 code: echo \"{{ variables.default.value }}\" In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: shell title: a simple example 1 code: echo \"{{ model.attributest.description }}\" The rules on how to access the individual elements of a model are explained here .","title":"Shell task"},{"location":"shell/#shell-task","text":"This page doesn't intend to explain Unix shell. So please refer to official Unix shell documentation for details on it. It's about the Unix shell task.","title":"Shell task"},{"location":"shell/#minimal-example","text":"The minimal example does not require a variable but the task does have one (always) with the name ' default '. The default regex is the whole text, and the default group is 0. --- taskgroups: - title: test tasks: - type: shell code: echo \"hello world!\"","title":"Minimal example"},{"location":"shell/#minimal-example-with-tags","text":"The application can be called with the repeatable option --tag. Specifying the those filter task will be executed only contain those tags. Task with other tags or even without any tags will be ignored then. --- taskgroups: - title: test tasks: - type: shell code: echo \"hello world!\" tags: - simple - example","title":"Minimal example with tags"},{"location":"shell/#example-with-variable","text":"The example with variable shows how to use the variable to extract information. It's exactly the same way as it does work for other tasks. You can specify the regex for filtering and - if required - the regex group; the default group is 0. --- taskgroups: - title: test tasks: - type: shell title: a simple example code: echo \"---> this is a demo <---\" variable: name: test2 regex: \">(.*)<\" group: 1","title":"Example with variable"},{"location":"shell/#example-with-templating","text":"The task group does store a map of key/value where key is the name of the variable, and the value is a variable. If you do not specify a name for a variable the name is ' default '. In the following example the first task does write 'hello world!' into the variable, and the second task does evaluate the value from the first task. Of course the second one write into the same variable its output since also there no name has been specified. --- taskgroups: - title: test tasks: - type: shell title: a simple example 1 code: echo \"hello world!\" - type: shell title: a simple example 2 code: echo \"{{ variables.default.value }}\" In addition, you can evaluate the model if you have one. --- model: description: some description taskgroups: - title: test tasks: - type: shell title: a simple example 1 code: echo \"{{ model.attributest.description }}\" The rules on how to access the individual elements of a model are explained here .","title":"Example with templating"},{"location":"templating/","text":"Templating Introduction One of the most powerful feature of the Hyperion tool is the templating that allows you to the dynamic replacement in the code of the part. Hyperion offers currently two data sources: the model the task group variables The model is a kind of freestyle hierarchical structure you can define to model the required data when running your tasks. The task group variables are initially empty and filled whenever a task has finished successfully. Accessing the variables Assuming you missed defining a variable on a task the name of a variable is \"default\". You then can access the variable in your task code with {{ variables.default.value }} . Assuming you evaluate a special path in your task writing it to a named variable \"path\" the possible evaluation in the next task would be {{ variables.path.value }} . It depends on of course whether tasks are running ordered or in parallel whether one task can read a variable of a previous task. Even more it's unpredictable for parallel tasks with same names to know which value will be given when you access it. Accessing the model The model - once understood - is a great way to modularize your task code also allowing reuse. For the next examples a few explanations: attributes - the term means that the object behind stores for a key a value; of course the can be multiple keys. The value can be a string, a number, a boolean, a list or - again - a key/value object. values - the means a list. The value can be a string, a number, a boolean or a key/value object. --- model: description: this is a simple example Trying to access this description you have to write {{ model.attributes.description }} . --- model: subModel: description: this is a simple example Here the value you get with {{ model.attributes.subModel.attributes.description }} --- model: descriptions: - this is a simple example Here the value you get with {{ model.attributes.descriptions.values[0] }} . model: actions: - name: action A command: println 'hello world 1 !' Here the name and the command can be accessed this way: {{ model.attributes.actions.values[0].attributes.name }} {{ model.attributes.actions.values[0].attributes.command }} If you want to know more about how this works then please also read here: https://pebbletemplates.io/wiki/guide/basic-usage/ (it shows internal usage as well as what you can do with it) (Near) Future enhancements Matrix variables (a matrix runs all task groups again for a different set of variables) Defining task group variables in the document","title":"Templating"},{"location":"templating/#templating","text":"","title":"Templating"},{"location":"templating/#introduction","text":"One of the most powerful feature of the Hyperion tool is the templating that allows you to the dynamic replacement in the code of the part. Hyperion offers currently two data sources: the model the task group variables The model is a kind of freestyle hierarchical structure you can define to model the required data when running your tasks. The task group variables are initially empty and filled whenever a task has finished successfully.","title":"Introduction"},{"location":"templating/#accessing-the-variables","text":"Assuming you missed defining a variable on a task the name of a variable is \"default\". You then can access the variable in your task code with {{ variables.default.value }} . Assuming you evaluate a special path in your task writing it to a named variable \"path\" the possible evaluation in the next task would be {{ variables.path.value }} . It depends on of course whether tasks are running ordered or in parallel whether one task can read a variable of a previous task. Even more it's unpredictable for parallel tasks with same names to know which value will be given when you access it.","title":"Accessing the variables"},{"location":"templating/#accessing-the-model","text":"The model - once understood - is a great way to modularize your task code also allowing reuse. For the next examples a few explanations: attributes - the term means that the object behind stores for a key a value; of course the can be multiple keys. The value can be a string, a number, a boolean, a list or - again - a key/value object. values - the means a list. The value can be a string, a number, a boolean or a key/value object. --- model: description: this is a simple example Trying to access this description you have to write {{ model.attributes.description }} . --- model: subModel: description: this is a simple example Here the value you get with {{ model.attributes.subModel.attributes.description }} --- model: descriptions: - this is a simple example Here the value you get with {{ model.attributes.descriptions.values[0] }} . model: actions: - name: action A command: println 'hello world 1 !' Here the name and the command can be accessed this way: {{ model.attributes.actions.values[0].attributes.name }} {{ model.attributes.actions.values[0].attributes.command }} If you want to know more about how this works then please also read here: https://pebbletemplates.io/wiki/guide/basic-usage/ (it shows internal usage as well as what you can do with it)","title":"Accessing the model"},{"location":"templating/#near-future-enhancements","text":"Matrix variables (a matrix runs all task groups again for a different set of variables) Defining task group variables in the document","title":"(Near) Future enhancements"}]}